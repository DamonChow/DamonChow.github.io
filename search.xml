<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[折腾Java设计模式之状态模式]]></title>
    <url>%2F2018%2F12%2F24%2Fdesign-pattern-state%2F</url>
    <content type="text"><![CDATA[状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。通俗点就是一个对象在内部状态发生改变时改变它的行为。 介绍意图 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用 代码中包含大量与对象状态有关的条件语句。 如何解决 将各种具体的状态类抽象出来。 关键代码 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 UML图 主要角色 1）Context(环境类)：环境类拥有各种不同状态的对象，作为外部使用的接口，负责调用状态类接口。 2）State(抽象状态)：抽象状态既可以为抽象类，也可以直接定义成接口。主要用于定义状态抽象方法，具体实现由子类负责。 3）ConcreteState(具体状态类):具体状态类为抽象状态的实现者，不同的状态类对应这不同的状态，其内部实现也不相同。环境类中使用不同状态的对象时，能实现不同的处理逻辑 应用实例 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景 行为随状态改变而改变的场景。 条件、分支语句的代替者。 状态模式和策略模式的对比现在我们知道，状态模式和策略模式的结构是相似的，但它们的意图不同。让我们重温一下它们的主要不同之处： 策略模式封装了一组相关算法，它允许Client在运行时使用可互换的行为；状态模式帮助一个类在不同的状态显示不同的行为。 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而通过从Context中分离出策略或算法，我们可以重用它们。 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。 策略实现可以作为参数传递给使用它的对象，例如Collections.sort()，它的参数包含一个Comparator策略。另一方面，状态是Context对象自己的一部分，随着时间的推移，Context对象从一个状态转移到另一个状态。 虽然它们都符合OCP原则，策略模式也符合SRP原则（单一职责原则），因为每个策略都封装自己的算法，且不依赖其他策略。一个策略的改变，并不会导致其他策略的变化。 另一个理论上的不同：策略模式定义了对象“怎么做”的部分。例如，排序对象怎么对数据排序。状态模式定义了对象“是什么”和“什么时候做”的部分。例如，对象处于什么状态，什么时候处在某个特定的状态。 状态模式中很好的定义了状态转移的次序；而策略模式并无此需要：Client可以自由的选择任何策略。 一些常见的策略模式的例子是封装算法，例如排序算法，加密算法或者压缩算法。如果你看到你的代码需要使用不同类型的相关算法，那么考虑使用策略模式吧。而识别何时使用状态模式是很简单的：如果你需要管理状态和状态转移，但不想使用大量嵌套的条件语句，那么就是它了。 最后但最重要的一个不同之处是，策略的改变由Client完成；而状态的改变，由Context或状态自己。 项目实例跳转到我的源码地址 simple1包中主要是对风扇的开关状态进行转换，其实我们是把状态放在状态类中进行按照固定的逻辑转换，但是这种模式其实他不符合开闭原则，为什么了，因为一旦我们发生新增、修改或者删除状态的时候，就需要修改状态类中的状态转换。 123456789101112public class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new CloseLevelState()); context.right(); context.right(); context.right(); context.left(); context.right(); context.right(); &#125;&#125; 抽象状态 12345678910111213141516171819202122public interface LevelState &#123; /** * 左转 * * @param context */ void left(Context context); /** * 右转 * * @param context */ void right(Context context); /** * 当前档位 * @return */ String info();&#125; 具体档位状态，我只列了2个，其他的类似 12345678910111213141516171819202122@Slf4jpublic class OneLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new CloseLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new TwoLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "1档"; &#125;&#125; 1234567891011121314151617181920212223@Slf4jpublic class CloseLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new ForeLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new OneLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "0档"; &#125;&#125; 真正的开关也就是上下文 123456789101112131415161718@Data@AllArgsConstructorpublic class Context &#123; private LevelState levelState; public void left() &#123; levelState.left(this); &#125; public void right() &#123; levelState.right(this); &#125; public String info() &#123; return levelState.info(); &#125;&#125; 参考Java中，状态模式和策略模式的区别 状态模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之责任链模式]]></title>
    <url>%2F2018%2F12%2F21%2Fdesign-pattern-chain%2F</url>
    <content type="text"><![CDATA[责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 简介意图 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用 在处理消息的时候以过滤很多道。 如何解决 拦截的类都实现统一接口。 关键代码 Handler 里面聚合它自己，在 handleRequest 里判断是否合适，如果没达到条件则向下传递。 纯责任链与不纯责任链 纯：纯责任链中的节点只有两种行为，一处理责任，二将责任传递到下一个节点。不允许出现某一个节点处理部分或全部责任后又将责任向下传递的情况。 不纯：允许某个请求被一个节点处理部分责任后再向下传递，或者处理完后其后续节点可以继续处理该责任，而且一个责任可以最终不被任何节点所处理。 主要角色 Handler（抽象处理者）： 定义一个处理请求的接口，提供对后续处理者的引用 ConcreteHandler（具体处理者）： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发 应用实例 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 Github项目描述跳转到我的责任链设计模式源码 1.出行方式travel包里主要对出行方式的责任链模式。跟进用户身上的钱，在优先级如飞机-&gt;火车-&gt;大巴的顺序下选择对应的出行模式。 123456789101112131415public class Application &#123; public static void main(String[] args) &#123; Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); planeHandler.setNext(trainHandler); trainHandler.setNext(busHandler); planeHandler.handleRequest("老王", 40d); planeHandler.handleRequest("张三", 140d); planeHandler.handleRequest("李四", 240d); planeHandler.handleRequest("吴老五", 340d); &#125;&#125; 抽象处理 12345678910@Datapublic abstract class Handler &#123; /** * 下一个链节点 */ protected Handler next; public abstract void handleRequest(String name, Double wallet);&#125; 具体的处理者（飞机、火车、大巴） 123456789101112131415161718@Slf4jpublic class PlaneHandler extends Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class TrainHandler extends Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class BusHandler extends Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 2.出行方式2，参考Filter链的写法travel2包是对travel包的重新写法。 1234567891011121314151617public class Application &#123; public static void main(String[] args) &#123; HandlerChain chain = new HandlerChain(); Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); chain.addHandler(planeHandler); chain.addHandler(trainHandler); chain.addHandler(busHandler); chain.handle("老王", 40d); chain.handle("张三", 140d); chain.handle("李四", 240d); chain.handle("吴老五", 340d); &#125;&#125; 抽象处理者 1234public interface Handler &#123; void handleRequest(String name, Double wallet, HandlerChain chain);&#125; 具体处理者（飞机、火车、大巴） 123456789101112131415@Slf4jpublic class PlaneHandler implements Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class TrainHandler implements Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class BusHandler implements Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 责任链管理者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Slf4jpublic class HandlerChain &#123; private List&lt;Handler&gt; handlerList = new ArrayList&lt;&gt;(); /** * 维护当前链上位置 */ private int pos; /** * 链的长度 */ private int handlerLength; public void addHandler(Handler handler) &#123; handlerList.add(handler); handlerLength = handlerList.size(); &#125; public void handle(String name, double wallet) &#123; if (CollectionUtils.isEmpty(handlerList)) &#123; log.error("有钱，但没提供服务，&#123;&#125;也估计就只能步行了。", name); return; &#125; if (pos &gt;= handlerLength) &#123; log.error("身上钱不够，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; Handler handler = handlerList.get(pos++); if (Objects.isNull(handler)) &#123; log.error("假服务，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; handler.handleRequest(name, wallet, this); &#125; /** * 链重新使用 */ public void reuse() &#123; pos = 0; &#125;&#125; 学习Java的Filter待补充… 参考维基的责任链模式 责任链模式|菜鸟教程 南乡清水的实际项目运用之Responsibility-Chain模式 一起学设计模式 - 责任链模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之策略模式]]></title>
    <url>%2F2018%2F12%2F20%2Fdesign-pattern-strategy%2F</url>
    <content type="text"><![CDATA[策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。简单理解就是一组算法，可以互换，再简单点策略就是封装算法。 意图 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用 一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决 将这些算法封装成一个一个的类，任意地替换。 主要角色 上下文Context，拥有一个Strategy的引用 抽象策略Strategy，往往是一个接口(占大部分情况)或者抽象类，通常提供各种具体策略的接口 具体策略，这就是重点了，封装了各种具体的算法 UML 应用实例 诸葛亮的锦囊妙计，每一个锦囊就是一个策略； 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略； JAVA AWT 中的 LayoutManager； 优点 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 项目描述跳转到我的策略模式GitHub 1.操作行为simple1包，主要对操作行为包装了加减乘除方法。 1234567891011121314151617@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new AddStrategy()); log.info("10 + 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new SubstractStrategy()); log.info("10 - 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new MultiplyStrategy()); log.info("10 * 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new DivideStrategy()); log.info("10 / 5 = &#123;&#125;", context.executeStrategy(10, 5)); &#125;&#125; 执行结果 2.出现方式simple2包描述，主要对出行方式的包装，包装了3种出行方式， 执行类 12345678910111213public class TravelApplication &#123; public static void main(String[] args) &#123; Context context = new Context(new BusStrategy()); context.executeStrategy("老王"); context.setStrategy(new BicycleStrategy()); context.executeStrategy("老张"); context.setStrategy(new WalkStrategy()); context.executeStrategy("老李"); &#125;&#125; 执行结果 策略上下文 12345678910111213141516171819@Datapublic class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 出行 * * @return */ public void executeStrategy(String name) &#123; strategy.travel(name); &#125;&#125; 抽象策略 123456789public interface Strategy &#123; /** * 出现方法 * * @return */ void travel(String name);&#125; 参考策略模式|菜鸟教程 维基里的策略模式 南乡清水的实际项目运用之Strategy模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式汇总]]></title>
    <url>%2F2018%2F12%2F19%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[设计模式23种设计模式大纲… 构建模式 Builder （建造者模式） Abstract Factory （抽象工厂模式） Factory Method （工厂方法） Prototype （原型模式） Singleton （单例模式） 结构模式 Adapter （适配器模式） Bridge （桥接模式） Composite （组合模式） Decorator （装饰模式） Facade （外观模式） Flyweight （享元模式） Proxy （代理模式） 行为模式 Chain of Responsibility（责任链模式） Command （命令模式） Interpreter （解释器模式） Iterator（迭代器模式） Mediator（中介者模式） Memento（备忘录模式） Observer（观察者模式） State（状态模式） Strategy (策略模式) Template Method （模板方法） Visitor（访问者模式）]]></content>
      <categories>
        <category>设计模式</category>
        <category>汇总</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试评论]]></title>
    <url>%2F2018%2F12%2F18%2Ftest%2F</url>
    <content type="text"><![CDATA[测试评论]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
