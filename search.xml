<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[折腾Java设计模式之命令模式]]></title>
    <url>%2F2019%2F01%2F02%2Fdesign-pattern-command%2F</url>
    <content type="text"><![CDATA[命令模式 wiki上的描述 Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests, and the queuing or logging of requests. It also allows for the support of undoable operations. 翻译意思，把请求封装成一个对象，从而允许我们可以对客户端的不同请求进行参数化，以及对请求进行排队或记录。还允许支持撤销操作。看起来好像很复杂，很难理解。 通俗简单理解，它就是将请求封装成一个对象，在这里就是这个对象就是命令，而这个命令就是将请求方和执行方分离隔开。从而每一个命令其实就是操作，而这样的流程就是请求方发出请求要求执行某操作，接收方收到请求后并执行对应的操作。这样下来，请求方和接收方就解耦了，使得请求方完全不知道接受的操作方法，从也不会知道接收方是何时接受到请求的，又是何时执行操作的，又是怎么执行操作的。 具体的角色 Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。 ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。 Invoker（请求方）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。 Receiver（接收方）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。 Client（客户端）：创建具体命令的对象并且设置命令对象的接受者。 再来看看UML图 从上方的时序图中可以看出运行的顺序，Invoker执行execute方法，调用Command1对象，Command1执行action1方法调用Receiver1对象。 干货代码源码在我的GitHub地址 普通的命令模式现在结合下上回说到的状态模式一起来实现这个风扇的左转和右转功能，这次把他用命令模式来代替之前风扇的转动，把它当做命令来。 客户端简单的定义请求方和接收方以及对于的左转命令和右转命令，设置命令后对应的执行命令。 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.setCommand(leftCommand); invoker.execute(); invoker.execute(); &#125;&#125; 请求方 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125;&#125; 抽象命令 1234public interface Command &#123; void execute();&#125; 开关左转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125;&#125; 开关右转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 通过命令模式把左转和右转封装成命令，以及之前的状态模式变更风扇的状态。本次就是通过状态模式和命令模式实现了一个风扇开关左右转的功能。 宏命令或者叫做组合命令设计一组命令，简单的处理事情，打印一句话，封装成一组命令。这次我们用了Java8来写，可以使用lambda。 12345678910111213141516171819202122232425262728@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); log.info("初始化ABC3个命令"); Command aCommand = () -&gt; log.info("A处理这个请求"); invoker.addCommand(aCommand); invoker.addCommand(() -&gt; log.info("B处理这个请求")); invoker.addCommand(() -&gt; log.info("C处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令D"); invoker.addCommand(() -&gt; log.info("D处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令E"); invoker.addCommand(() -&gt; log.info("E处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("移除命令A"); invoker.removeCommand(aCommand); invoker.execute(); &#125;&#125; 打印语句。 抽象命令 12345@FunctionalInterfacepublic interface Command &#123; void execute();&#125; 请求方 1234567891011121314151617181920212223@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private List&lt;Command&gt; commandList = Lists.newArrayList(); public void addCommand(Command command) &#123; commandList.add(command); &#125; public void removeCommand(Command command) &#123; commandList.remove(command); &#125; public void execute() &#123; if(CollectionUtils.isEmpty(commandList)) &#123; return; &#125; commandList.stream().forEach(command -&gt; command.execute()); &#125;&#125; 撤销操作在普通的命令模式的基础上，增加了撤销操作，在这里的撤销操作，其实即为左转时的右转，右转时的左转。 123456789101112131415161718192021@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.undo(); invoker.undo(); invoker.setCommand(leftCommand); invoker.execute(); invoker.undo(); &#125;&#125; 抽象命令增加了撤销操作 123456public interface Command &#123; void execute(); void undo();&#125; 具体左转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125; @Override public void undo() &#123; receiver.right(); &#125;&#125; 右转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125; @Override public void undo() &#123; receiver.left(); &#125;&#125; 请求方 12345678910111213141516@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125; public void undo() &#123; command.undo(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 命令模式总结优点 (1) 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 (2) 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 (3) 可以比较容易地设计一个命令队列或宏命令（组合命令）。 (4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。 适用场景 (1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 (2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 (3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 (4) 系统需要将一组操作组合在一起形成宏命令。 (5)线程池有一个addTash方法，将任务添加到待完成的队列中，队列中的元素就是命令对象，通常的就是一个公共接口，像我们常用的java.lang.Runnable接口。 (6)java8之后，最好在Command接口中@FunctionalInterface修饰，这样具体的命令就可以使用lambda表达式啦。 Java中的使用将操作封装到对象内，以便存储，传递和返回。 java.lang.Runnable javax.swing.Action 文章参考java设计模式之命令模式 细数JDK里的设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之状态模式]]></title>
    <url>%2F2018%2F12%2F24%2Fdesign-pattern-state%2F</url>
    <content type="text"><![CDATA[状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。通俗点就是一个对象在内部状态发生改变时改变它的行为。 介绍意图 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用 代码中包含大量与对象状态有关的条件语句。 如何解决 将各种具体的状态类抽象出来。 关键代码 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 UML图 主要角色 1）Context(环境类)：环境类拥有各种不同状态的对象，作为外部使用的接口，负责调用状态类接口。 2）State(抽象状态)：抽象状态既可以为抽象类，也可以直接定义成接口。主要用于定义状态抽象方法，具体实现由子类负责。 3）ConcreteState(具体状态类):具体状态类为抽象状态的实现者，不同的状态类对应这不同的状态，其内部实现也不相同。环境类中使用不同状态的对象时，能实现不同的处理逻辑 应用实例 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景 行为随状态改变而改变的场景。 条件、分支语句的代替者。 状态模式和策略模式的对比现在我们知道，状态模式和策略模式的结构是相似的，但它们的意图不同。让我们重温一下它们的主要不同之处： 策略模式封装了一组相关算法，它允许Client在运行时使用可互换的行为；状态模式帮助一个类在不同的状态显示不同的行为。 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而通过从Context中分离出策略或算法，我们可以重用它们。 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。 策略实现可以作为参数传递给使用它的对象，例如Collections.sort()，它的参数包含一个Comparator策略。另一方面，状态是Context对象自己的一部分，随着时间的推移，Context对象从一个状态转移到另一个状态。 虽然它们都符合OCP原则，策略模式也符合SRP原则（单一职责原则），因为每个策略都封装自己的算法，且不依赖其他策略。一个策略的改变，并不会导致其他策略的变化。 另一个理论上的不同：策略模式定义了对象“怎么做”的部分。例如，排序对象怎么对数据排序。状态模式定义了对象“是什么”和“什么时候做”的部分。例如，对象处于什么状态，什么时候处在某个特定的状态。 状态模式中很好的定义了状态转移的次序；而策略模式并无此需要：Client可以自由的选择任何策略。 一些常见的策略模式的例子是封装算法，例如排序算法，加密算法或者压缩算法。如果你看到你的代码需要使用不同类型的相关算法，那么考虑使用策略模式吧。而识别何时使用状态模式是很简单的：如果你需要管理状态和状态转移，但不想使用大量嵌套的条件语句，那么就是它了。 最后但最重要的一个不同之处是，策略的改变由Client完成；而状态的改变，由Context或状态自己。 项目实例跳转到我的源码地址 simple1包中主要是对风扇的开关状态进行转换，其实我们是把状态放在状态类中进行按照固定的逻辑转换，但是这种模式其实他不符合开闭原则，为什么了，因为一旦我们发生新增、修改或者删除状态的时候，就需要修改状态类中的状态转换。 123456789101112public class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new CloseLevelState()); context.right(); context.right(); context.right(); context.left(); context.right(); context.right(); &#125;&#125; 抽象状态 12345678910111213141516171819202122public interface LevelState &#123; /** * 左转 * * @param context */ void left(Context context); /** * 右转 * * @param context */ void right(Context context); /** * 当前档位 * @return */ String info();&#125; 具体档位状态，我只列了2个，其他的类似 12345678910111213141516171819202122@Slf4jpublic class OneLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new CloseLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new TwoLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "1档"; &#125;&#125; 1234567891011121314151617181920212223@Slf4jpublic class CloseLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new ForeLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new OneLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "0档"; &#125;&#125; 真正的开关也就是上下文 123456789101112131415161718@Data@AllArgsConstructorpublic class Context &#123; private LevelState levelState; public void left() &#123; levelState.left(this); &#125; public void right() &#123; levelState.right(this); &#125; public String info() &#123; return levelState.info(); &#125;&#125; 参考Java中，状态模式和策略模式的区别 状态模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之责任链模式]]></title>
    <url>%2F2018%2F12%2F21%2Fdesign-pattern-chain%2F</url>
    <content type="text"><![CDATA[责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 简介意图 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用 在处理消息的时候以过滤很多道。 如何解决 拦截的类都实现统一接口。 关键代码 Handler 里面聚合它自己，在 handleRequest 里判断是否合适，如果没达到条件则向下传递。 纯责任链与不纯责任链 纯：纯责任链中的节点只有两种行为，一处理责任，二将责任传递到下一个节点。不允许出现某一个节点处理部分或全部责任后又将责任向下传递的情况。 不纯：允许某个请求被一个节点处理部分责任后再向下传递，或者处理完后其后续节点可以继续处理该责任，而且一个责任可以最终不被任何节点所处理。 主要角色 Handler（抽象处理者）： 定义一个处理请求的接口，提供对后续处理者的引用 ConcreteHandler（具体处理者）： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发 应用实例 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 Github项目描述跳转到我的责任链设计模式源码 1.出行方式travel包里主要对出行方式的责任链模式。跟进用户身上的钱，在优先级如飞机-&gt;火车-&gt;大巴的顺序下选择对应的出行模式。 123456789101112131415public class Application &#123; public static void main(String[] args) &#123; Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); planeHandler.setNext(trainHandler); trainHandler.setNext(busHandler); planeHandler.handleRequest("老王", 40d); planeHandler.handleRequest("张三", 140d); planeHandler.handleRequest("李四", 240d); planeHandler.handleRequest("吴老五", 340d); &#125;&#125; 抽象处理 12345678910@Datapublic abstract class Handler &#123; /** * 下一个链节点 */ protected Handler next; public abstract void handleRequest(String name, Double wallet);&#125; 具体的处理者（飞机、火车、大巴） 123456789101112131415161718@Slf4jpublic class PlaneHandler extends Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class TrainHandler extends Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class BusHandler extends Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 2.出行方式2，参考Filter链的写法travel2包是对travel包的重新写法。 1234567891011121314151617public class Application &#123; public static void main(String[] args) &#123; HandlerChain chain = new HandlerChain(); Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); chain.addHandler(planeHandler); chain.addHandler(trainHandler); chain.addHandler(busHandler); chain.handle("老王", 40d); chain.handle("张三", 140d); chain.handle("李四", 240d); chain.handle("吴老五", 340d); &#125;&#125; 抽象处理者 1234public interface Handler &#123; void handleRequest(String name, Double wallet, HandlerChain chain);&#125; 具体处理者（飞机、火车、大巴） 123456789101112131415@Slf4jpublic class PlaneHandler implements Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class TrainHandler implements Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class BusHandler implements Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 责任链管理者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Slf4jpublic class HandlerChain &#123; private List&lt;Handler&gt; handlerList = new ArrayList&lt;&gt;(); /** * 维护当前链上位置 */ private int pos; /** * 链的长度 */ private int handlerLength; public void addHandler(Handler handler) &#123; handlerList.add(handler); handlerLength = handlerList.size(); &#125; public void handle(String name, double wallet) &#123; if (CollectionUtils.isEmpty(handlerList)) &#123; log.error("有钱，但没提供服务，&#123;&#125;也估计就只能步行了。", name); return; &#125; if (pos &gt;= handlerLength) &#123; log.error("身上钱不够，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; Handler handler = handlerList.get(pos++); if (Objects.isNull(handler)) &#123; log.error("假服务，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; handler.handleRequest(name, wallet, this); &#125; /** * 链重新使用 */ public void reuse() &#123; pos = 0; &#125;&#125; 学习Web项目的Filter待补充… 补充补充遗留的Filter过滤器中的责任链处理。 本次主要是对Tomcat中的Filter处理简单的梳理，如有不正确的地方，还望指出来，大家互勉，共进。 老项目大家可以在web.xml中配置filter，现使用Springboot后，也有两种配置filter方式，通过创建FilterRegistrationBean的方式和通过注解@WebFilter+@ServletComponentScan的方式。 三个主要的角色 FIlter，不多介绍了。 FilterChain servlet容器提供的开发调用链的过滤请求的资源。通过调用下一个filter实现过滤，在整体链上。 FilterConfig filter的配置器，在servlet容器在Filter初始化的时候传递信息。 具体的filter，主要说说Spring中的两个抽象Filter，GenericFilterBean和OncePerRequestFilter。 前者主要是做init和destroy的操作，重点还是init方法，destroy只是空实现而已。 后者主要是做真正的doFilter操作，也是我们在Spring中创建Filter通常继承的。 而ApplicationFilterChain就算Tomcat中的FilterChain实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 /** * The int which is used to maintain the current position * in the filter chain. */ private int pos = 0; /** * The int which gives the current number of filters in the chain. */ private int n = 0;@Overridepublic void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //安全相关的，暂不关注 if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; try &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123; @Override public Void run() throws ServletException, IOException &#123; internalDoFilter(req,res); return null; &#125; &#125; ); &#125; catch( PrivilegedActionException pe) &#123; Exception e = pe.getException(); if (e instanceof ServletException) throw (ServletException) e; else if (e instanceof IOException) throw (IOException) e; else if (e instanceof RuntimeException) throw (RuntimeException) e; else throw new ServletException(e.getMessage(), e); &#125; &#125; else &#123; //真正的doFilter internalDoFilter(request,response); &#125;&#125;private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //pos 调用链中当前连接点所在的位置 //n 调用链总节点长度 // Call the next filter if there is one if (pos &lt; n) &#123; //对节点进行自增 pos++ ApplicationFilterConfig filterConfig = filters[pos++]; try &#123; //当前节点小于总长度后，从filter配置类中取出filter Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() &amp;&amp; "false".equalsIgnoreCase( filterConfig.getFilterDef().getAsyncSupported())) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res, this&#125;; SecurityUtil.doAsPrivilege ("doFilter", filter, classType, args, principal); &#125; else &#123; //真正的filter filter.doFilter(request, response, this); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.filter"), e); &#125; return; &#125; // We fell off the end of the chain -- call the servlet instance //到了调用链结尾处，就真正调用servlet实例的servlet.service(request, response); try &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // Use potentially wrapped request from this point if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res&#125;; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args, principal); &#125; else &#123; servlet.service(request, response); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.servlet"), e); &#125; finally &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(null); lastServicedResponse.set(null); &#125; &#125;&#125;/*** Prepare for reuse of the filters and wrapper executed by this chain.* 重复使用filter调用链，pos重设为0*/void reuse() &#123; pos = 0;&#125; 重点从ApplicationFilterChain中挑出几个重要的方法拿出来分析下Filter的调用链，其实还有几处没有具体讲到，ApplicationFilterChain是合适创建的，Filter是怎么加入到ApplicationFilterChain中的。这涉及到Tomcat是怎样加载Content的，下次分析Tomcat的时候，再来具体分析，它是如何运作的，如何加载web.xml。 参考维基的责任链模式 责任链模式|菜鸟教程 Filter、FilterConfig、FilterChain|菜鸟教程 南乡清水的实际项目运用之Responsibility-Chain模式 一起学设计模式 - 责任链模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之策略模式]]></title>
    <url>%2F2018%2F12%2F20%2Fdesign-pattern-strategy%2F</url>
    <content type="text"><![CDATA[策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。简单理解就是一组算法，可以互换，再简单点策略就是封装算法。 意图 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用 一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决 将这些算法封装成一个一个的类，任意地替换。 主要角色 上下文Context，拥有一个Strategy的引用 抽象策略Strategy，往往是一个接口(占大部分情况)或者抽象类，通常提供各种具体策略的接口 具体策略，这就是重点了，封装了各种具体的算法 UML 应用实例 诸葛亮的锦囊妙计，每一个锦囊就是一个策略； 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略； JAVA AWT 中的 LayoutManager； 优点 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 项目描述跳转到我的策略模式GitHub 1.操作行为simple1包，主要对操作行为包装了加减乘除方法。 1234567891011121314151617@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new AddStrategy()); log.info("10 + 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new SubstractStrategy()); log.info("10 - 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new MultiplyStrategy()); log.info("10 * 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new DivideStrategy()); log.info("10 / 5 = &#123;&#125;", context.executeStrategy(10, 5)); &#125;&#125; 执行结果 2.出现方式simple2包描述，主要对出行方式的包装，包装了3种出行方式， 执行类 12345678910111213public class TravelApplication &#123; public static void main(String[] args) &#123; Context context = new Context(new BusStrategy()); context.executeStrategy("老王"); context.setStrategy(new BicycleStrategy()); context.executeStrategy("老张"); context.setStrategy(new WalkStrategy()); context.executeStrategy("老李"); &#125;&#125; 执行结果 策略上下文 12345678910111213141516171819@Datapublic class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 出行 * * @return */ public void executeStrategy(String name) &#123; strategy.travel(name); &#125;&#125; 抽象策略 123456789public interface Strategy &#123; /** * 出现方法 * * @return */ void travel(String name);&#125; 参考策略模式|菜鸟教程 维基里的策略模式 南乡清水的实际项目运用之Strategy模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式汇总]]></title>
    <url>%2F2018%2F12%2F19%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[设计模式23种设计模式大纲… 构建模式 Builder （建造者模式） Abstract Factory （抽象工厂模式） Factory Method （工厂方法） Prototype （原型模式） Singleton （单例模式） 结构模式 Adapter （适配器模式） Bridge （桥接模式） Composite （组合模式） Decorator （装饰模式） Facade （外观模式） Flyweight （享元模式） Proxy （代理模式） 行为模式 Chain of Responsibility（责任链模式） Command （命令模式） Interpreter （解释器模式） Iterator（迭代器模式） Mediator（中介者模式） Memento（备忘录模式） Observer（观察者模式） State（状态模式） Strategy (策略模式) Template Method （模板方法） Visitor（访问者模式）]]></content>
      <categories>
        <category>设计模式</category>
        <category>汇总</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试评论]]></title>
    <url>%2F2018%2F12%2F18%2Ftest%2F</url>
    <content type="text"><![CDATA[测试评论]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
