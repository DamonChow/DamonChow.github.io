<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[debezium关于cdc的使用(下)]]></title>
    <url>%2F2019%2F08%2F07%2Fcdc-debezium-two%2F</url>
    <content type="text"><![CDATA[简介debezium在debezium关于cdc的使用(上)中有做介绍。具体可以跳到上文查看。本篇主要讲述使用kafka connector方式来同步数据。而kafka connector实际上也有提供其他的sink(Kafka Connect JDBC)来同步数据，但是没有delete事件。所以在这里选择了Debezium MySQL CDC Connector方式来同步。本文需要使用Avro方式序列化kafka数据。 流程第一步准备使用kafka消息中间介的话需要对应的服务支持，尤其需要chema-registry来管理schema，因电脑内存有限就没使用docker方式启动，如果条件ok内存够大的话阔以使用docker方式。所以使用的就是local本地方式。具体下载，安装，部署，配置环境变量我就不在重复描述了，阔以参考官方文档。 第二步启动kafka配套进入目录后启动bin/confluent start 第三步创建kafka topic可以通过kafka命令创建topic也可以通过Confluent Control Center 地址：http://localhost:9021来创建topic。我们还是按照上文的表来同步数据，所以创建topic：dbserver1.inventory.demo。 第四步创建kafka connect可以通过kafka rest命令创建也可以使用Confluent Control Center创建。 connect的api命令参考 方便点可以使用crul创建，以下为配置文件 123456789101112131415161718192021&#123; "name": "inventory-connector", "config": &#123; "connector.class": "io.debezium.connector.mysql.MySqlConnector", "tasks.max": "1", "database.hostname": "localhost", "database.port": "3306", "database.user": "debezium", "database.password": "dbz", "database.server.id": "184054", "database.server.name": "dbserver1", "database.whitelist": "inventory", "decimal.handling.mode": "double", "key.converter": "io.confluent.connect.avro.AvroConverter", "key.converter.schema.registry.url": "http://localhost:8081", "value.converter": "io.confluent.connect.avro.AvroConverter", "value.converter.schema.registry.url": "http://localhost:8081", "database.history.kafka.bootstrap.servers": "localhost:9092", "database.history.kafka.topic": "dbhistory.inventory" &#125;&#125; 创建好后可以使用命令查询到或者在管理中心查看。 命令：http://localhost:8083/connectors/inventory-connector 第五步启动同步程序配置12345678910111213141516171819202122spring: application: name: data-center datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/inventory_back?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC username: debe password: 123456 jpa: show-sql: true jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8# time-zone: UTC kafka: bootstrap-servers: localhost:9092 consumer: group-id: debezium-kafka-connector key-deserializer: "io.confluent.kafka.serializers.KafkaAvroDeserializer" value-deserializer: "io.confluent.kafka.serializers.KafkaAvroDeserializer" properties: schema.registry.url: http://localhost:8081 kafka消费者跟上文的处理流程是一样的。只不过DDL和DML分成2个监听器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.example.kakfa.avro;import com.example.kakfa.avro.sql.SqlProvider;import com.example.kakfa.avro.sql.SqlProviderFactory;import io.debezium.data.Envelope;import lombok.extern.slf4j.Slf4j;import org.apache.avro.generic.GenericData;import org.apache.commons.lang3.StringUtils;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.stereotype.Component;import java.util.Objects;import java.util.Optional;@Slf4j@Componentpublic class KafkaAvroConsumerRunner &#123; @Autowired private JdbcTemplate jdbcTemplate; @Autowired private NamedParameterJdbcTemplate namedTemplate; @KafkaListener(id = "dbserver1-ddl-consumer", topics = "dbserver1") public void listenerUser(ConsumerRecord&lt;GenericData.Record, GenericData.Record&gt; record) throws Exception &#123; GenericData.Record key = record.key(); GenericData.Record value = record.value(); log.info("Received record: &#123;&#125;", record); log.info("Received record: key &#123;&#125;", key); log.info("Received record: value &#123;&#125;", value); String databaseName = Optional.ofNullable(value.get("databaseName")).map(Object::toString).orElse(null); String ddl = Optional.ofNullable(value.get("ddl")).map(Object::toString).orElse(null); if (StringUtils.isBlank(ddl)) &#123; return; &#125; handleDDL(ddl, databaseName); &#125; /** * 执行数据库ddl语句 * * @param ddl */ private void handleDDL(String ddl, String db) &#123; log.info("ddl语句 : &#123;&#125;", ddl); try &#123; if (StringUtils.isNotBlank(db)) &#123; ddl = ddl.replace(db + ".", ""); ddl = ddl.replace("`" + db + "`.", ""); &#125; jdbcTemplate.execute(ddl); &#125; catch (Exception e) &#123; log.error("数据库操作DDL语句失败，", e); &#125; &#125; @KafkaListener(id = "dbserver1-dml-consumer", topicPattern = "dbserver1.inventory.*") public void listenerAvro(ConsumerRecord&lt;GenericData.Record, GenericData.Record&gt; record) throws Exception &#123; GenericData.Record key = record.key(); GenericData.Record value = record.value(); log.info("Received record: &#123;&#125;", record); log.info("Received record: key &#123;&#125;", key); log.info("Received record: value &#123;&#125;", value); if (Objects.isNull(value)) &#123; return; &#125; GenericData.Record source = (GenericData.Record) value.get("source"); String table = source.get("table").toString(); Envelope.Operation operation = Envelope.Operation.forCode(value.get("op").toString()); String db = source.get("db").toString(); handleDML(key, value, table, operation); &#125; private void handleDML(GenericData.Record key, GenericData.Record value, String table, Envelope.Operation operation) &#123; SqlProvider provider = SqlProviderFactory.getProvider(operation); if (Objects.isNull(provider)) &#123; log.error("没有找到sql处理器提供者."); return; &#125; String sql = provider.getSql(key, value, table); if (StringUtils.isBlank(sql)) &#123; log.error("找不到sql."); return; &#125; try &#123; log.info("dml语句 : &#123;&#125;", sql); namedTemplate.update(sql, provider.getSqlParameterMap()); &#125; catch (Exception e) &#123; log.error("数据库DML操作失败，", e); &#125; &#125;&#125; 数据流程剩下的就是在inventory库中demo表中增删改数据，在对应的inventory_back库中demo表数据对应的改变。]]></content>
      <categories>
        <category>数据同步</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>cdc</tag>
        <tag>debezium</tag>
        <tag>kafka</tag>
        <tag>connector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debezium关于cdc的使用(上)]]></title>
    <url>%2F2019%2F06%2F24%2Fcdc-debezium-one%2F</url>
    <content type="text"><![CDATA[简介debezium是一个为了捕获数据变更(cdc)的开源的分布式平台。启动并指向数据库，当其他应用对此数据库执行inserts、updates、delete操作时，此应用快速得到响应。debezium是持久化和快速响应的，因此你的应用可以快速响应且不会丢失任意一条事件。debezium记录是数据库表的行级别的变更事件。同时debezium是构建在kafka之上的，同时与kafka深度耦合，所以提供kafka connector来使用，debezium sink。支持的数据库有mysql、MongoDB、PostgreSQL、Oracle、SQL server。本篇以mysql作为数据源来实现功能，监听msyql的binlog，还需要修改。当前版本是0.9.5.Final，0.10版本正在开发中。 配置本篇文章主要使用Embedding形式监听事件不借助MQ消息中间介，并同步更新到数据库。 下篇主要使用kafka connector来同步更新到数据库。 mysql需要如下开启binlog。但是如果使用的是debezium/mysql镜像，自动已经配置好了。 123log-bin=mysql-bin #添加这一行就okbinlog-format=ROW #选择row模式server_id=1 #配置mysql replaction需要定义，不能和canal的slaveId重复 开胃菜先来一个效果，主要是配置kafka connector来获取debezium事件记录。需要3个服务，zookeeper、kakfa和debezium connector。这里使用docker来启动的，所以需要先安装docker。 启动zookeeper1docker run -it --rm --name zookeeper -p 2181:2181 -p 2888:2888 -p 3888:3888 debezium/zookeeper:0.9 启动kafka1docker run -it --rm --name kafka -p 9092:9092 --link zookeeper:zookeeper debezium/kafka:0.9 启动mysql1docker run -it --rm --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=debezium -e MYSQL_USER=mysqluser -e MYSQL_PASSWORD=mysqlpw debezium/example-mysql:0.9 启动kafka connect1docker run -it --rm --name connect -p 8083:8083 -e GROUP_ID=1 -e CONFIG_STORAGE_TOPIC=my_connect_configs -e OFFSET_STORAGE_TOPIC=my_connect_offsets -e STATUS_STORAGE_TOPIC=my_connect_statuses --link zookeeper:zookeeper --link kafka:kafka --link mysql:mysql debezium/connect:0.9 通过connect的http请求创建debezium connector1curl -i -X POST -H "Accept:application/json" -H "Content-Type:application/json" localhost:8083/connectors/ -d '&#123; "name": "inventory-connector", "config": &#123; "connector.class": "io.debezium.connector.mysql.MySqlConnector", "tasks.max": "1", "database.hostname": "mysql", "database.port": "3306", "database.user": "debezium", "database.password": "dbz", "database.server.id": "184054", "database.server.name": "dbserver1", "database.whitelist": "inventory", "database.history.kafka.bootstrap.servers": "kafka:9092", "database.history.kafka.topic": "dbhistory.inventory" &#125; &#125;' mysql客户端操作通过invertory数据库了的任一表的数据 创建监听可以查看debezium事件记录1docker run -it --name watcher --rm --link zookeeper:zookeeper --link kafka:kafka debezium/kafka:0.9 watch-topic -a -k dbserver1.inventory.customers 内嵌式这里主要使用内嵌式的方式获取cdc事件而不需要使用kafka，直接消费debezium事件流。场景是在某一个mysql数据库里的table发生变更，把变更同步到另一mysql数据库。本次使用的是监听inventory数据库并将数据同步到inventory_back。 debezium配置123456789101112131415161718192021connector.class=io.debezium.connector.mysql.MySqlConnectoroffset.storage=org.apache.kafka.connect.storage.FileOffsetBackingStoreoffset.storage.file.filename=offset.datoffset.flush.interval.ms=60000name=debezium-kafka-sourcedatabase.hostname=localhostdatabase.port=3306database.user=debeziumdatabase.password=dbz#database.dbname=inventorydatabase.whitelist=inventory#database.whitelist=inventory,inventory_backserver.id=184054database.server.name=dbserver1#transforms=unwrap#transforms.unwrap.type=io.debezium.transforms.UnwrapFromEnvelope#transforms.unwrap.drop.tombstones=falsedatabase.history=io.debezium.relational.history.FileDatabaseHistorydatabase.history.file.filename=dbhistory.dat 属性和convert配置123456789101112131415161718192021222324252627282930313233343536@Slf4j@Configurationpublic class DebeziumEmbeddedAutoConfiguration &#123; @Bean public Properties embeddedProperties() &#123; Properties propConfig = new Properties(); try(InputStream propsInputStream = getClass().getClassLoader().getResourceAsStream("config.properties")) &#123; propConfig.load(propsInputStream); &#125; catch (IOException e) &#123; log.error("Couldn't load properties", e); &#125; PropertyLoader.loadEnvironmentValues(propConfig); return propConfig; &#125; @Bean public io.debezium.config.Configuration embeddedConfig(Properties embeddedProperties) &#123; return io.debezium.config.Configuration.from(embeddedProperties); &#125; @Bean public JsonConverter keyConverter(io.debezium.config.Configuration embeddedConfig) &#123; JsonConverter converter = new JsonConverter(); converter.configure(embeddedConfig.asMap(), true); return converter; &#125; @Bean public JsonConverter valueConverter(io.debezium.config.Configuration embeddedConfig) &#123; JsonConverter converter = new JsonConverter(); converter.configure(embeddedConfig.asMap(), false); return converter; &#125;&#125; 同步DDL和DML这里主要是利用CommandLineRunner特性，启动debezium的EmbeddedEngine引擎，获取到cdc事件后由handleRecord处理DDL和DML，需要去解析cdc的事件SourceRecord的key和value。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154@Slf4j@Order(2)@Componentpublic class DebeziumEmbeddedRunner implements CommandLineRunner &#123; @Autowired private io.debezium.config.Configuration embeddedConfig; @Autowired private JdbcTemplate jdbcTemplate; @Autowired private NamedParameterJdbcTemplate namedTemplate; @Autowired private JsonConverter keyConverter; @Autowired private JsonConverter valueConverter; @Override public void run(String... args) throws Exception &#123; EmbeddedEngine engine = EmbeddedEngine.create() .using(embeddedConfig) .using(this.getClass().getClassLoader()) .using(Clock.SYSTEM) .notifying(this::handleRecord) .build(); ExecutorService executor = Executors.newSingleThreadExecutor(); executor.execute(engine); shutdownHook(engine); awaitTermination(executor); &#125; /** * For every record this method will be invoked. */ private void handleRecord(SourceRecord record) &#123; logRecord(record); Struct payload = (Struct) record.value(); if (Objects.isNull(payload)) &#123; return; &#125; String table = Optional.ofNullable(DebeziumRecordUtils.getRecordStructValue(payload, "source")) .map(s-&gt;s.getString("table")).orElse(null);// // 处理数据DML Envelope.Operation operation = DebeziumRecordUtils.getOperation(payload); if (Objects.nonNull(operation)) &#123; Struct key = (Struct) record.key(); handleDML(key, payload, table, operation); return; &#125;//// // 处理结构DDL String ddl = getDDL(payload); if (StringUtils.isNotBlank(ddl)) &#123; handleDDL(ddl); &#125; &#125; private String getDDL(Struct payload) &#123; String ddl = DebeziumRecordUtils.getDDL(payload); if (StringUtils.isBlank(ddl)) &#123; return null; &#125; String db = DebeziumRecordUtils.getDatabaseName(payload); if (StringUtils.isBlank(db)) &#123; db = embeddedConfig.getString(MySqlConnectorConfig.DATABASE_WHITELIST); &#125; ddl = ddl.replace(db + ".", ""); ddl = ddl.replace("`" + db + "`.", ""); return ddl; &#125; /** * 执行数据库ddl语句 * * @param ddl */ private void handleDDL(String ddl) &#123; log.info("ddl语句 : &#123;&#125;", ddl); try &#123; jdbcTemplate.execute(ddl); &#125; catch (Exception e) &#123; log.error("数据库操作DDL语句失败，", e); &#125; &#125; /** * 处理insert,update,delete等DML语句 * * @param key 表主键修改事件结构 * @param payload 表正文响应 * @param table 表名 * @param operation DML操作类型 */ private void handleDML(Struct key, Struct payload, String table, Envelope.Operation operation) &#123; AbstractDebeziumSqlProvider provider = DebeziumSqlProviderFactory.getProvider(operation); if (Objects.isNull(provider)) &#123; log.error("没有找到sql处理器提供者."); return; &#125; String sql = provider.getSql(key, payload, table); if (StringUtils.isBlank(sql)) &#123; log.error("找不到sql."); return; &#125; try &#123; log.info("dml语句 : &#123;&#125;", sql); namedTemplate.update(sql, provider.getSqlParameterMap()); &#125; catch (Exception e) &#123; log.error("数据库DML操作失败，", e); &#125; &#125; /** * 打印消息 * * @param record */ private void logRecord(SourceRecord record) &#123; final byte[] payload = valueConverter.fromConnectData("dummy", record.valueSchema(), record.value()); final byte[] key = keyConverter.fromConnectData("dummy", record.keySchema(), record.key()); log.info("Publishing Topic --&gt; &#123;&#125;", record.topic()); log.info("Key --&gt; &#123;&#125;", new String(key)); log.info("Payload --&gt; &#123;&#125;", new String(payload)); &#125; private void shutdownHook(EmbeddedEngine engine) &#123; Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; log.info("Requesting embedded engine to shut down"); engine.stop(); &#125;)); &#125; private void awaitTermination(ExecutorService executor) &#123; try &#123; while (!executor.awaitTermination(10L, TimeUnit.SECONDS)) &#123; log.info("Waiting another 10 seconds for the embedded engine to shut down"); &#125; &#125; catch (InterruptedException e) &#123; Thread.interrupted(); &#125; &#125;&#125; provider和table字段解析器太多，这里就不在一一列出来了，如下图所示，支持mysql大部分字段类型。如果有需要的可以关注微信公众号或者邮件以及评论回复。 测试表结构1234567891011121314151617181920212223242526272829303132CREATE TABLE `demo` ( `id` int(10) NOT NULL AUTO_INCREMENT, `bigint_id` bigint(20) NOT NULL, `var_name` varchar(255) NOT NULL, `ex_tinyint` tinyint(4) DEFAULT NULL, `ex_char` char(255) DEFAULT NULL, `ex_json` json DEFAULT NULL COMMENT '水电费', `ex_text` text, `ex_year` year(4) DEFAULT NULL, `ex_time` time DEFAULT NULL, `ex_date` date DEFAULT NULL, `ex_datetime` datetime DEFAULT NULL, `ex_timestamp` timestamp NULL DEFAULT NULL, `ex_blob` blob, `ex_tinyblob` tinyblob, `ex_binary` binary(255) DEFAULT NULL, `ex_double` double(10,4) DEFAULT NULL, `ex_float` float(10,2) DEFAULT NULL, `ex_decimal` decimal(10,2) DEFAULT NULL, `ex_numeric` decimal(10,4) DEFAULT NULL, `ex_real` double(10,4) DEFAULT NULL, `ex_bit` bit(1) DEFAULT NULL, `ex_enum` enum('123','@@','22','水电费') DEFAULT '123', `ex_set` set('a','b','c','d') DEFAULT NULL, `ex_geometry` geometry DEFAULT NULL, `ex_point` point DEFAULT NULL, `ex_linestring` linestring DEFAULT NULL, `ex_polygon` polygon DEFAULT NULL, `ex_geometrycollection` geometrycollection DEFAULT NULL, `ex_multipoint` multipoint DEFAULT NULL, PRIMARY KEY (`id`,`bigint_id`,`var_name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 结果DDL事件可以看出将数据库表的bigint_id字段长度改为21，监听到事件后：执行了ddl语句，inventory_back库中的demo表的bigint_id字段长度改为21了。 123456Publishing Topic --&gt; dbserver12019-06-24 16:22:21.230 INFO 14995 --- [pool-1-thread-1] c.e.embedded.DebeziumEmbeddedRunner : Key --&gt; &#123;&quot;schema&quot;:&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;databaseName&quot;&#125;],&quot;optional&quot;:false,&quot;name&quot;:&quot;io.debezium.connector.mysql.SchemaChangeKey&quot;&#125;,&quot;payload&quot;:&#123;&quot;databaseName&quot;:&quot;inventory&quot;&#125;&#125;2019-06-24 16:22:21.230 INFO 14995 --- [pool-1-thread-1] c.e.embedded.DebeziumEmbeddedRunner : Payload --&gt; &#123;&quot;schema&quot;:&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;version&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;connector&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;server_id&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;ts_sec&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;gtid&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;file&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;pos&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;row&quot;&#125;,&#123;&quot;type&quot;:&quot;boolean&quot;,&quot;optional&quot;:true,&quot;default&quot;:false,&quot;field&quot;:&quot;snapshot&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;thread&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;db&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;table&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;query&quot;&#125;],&quot;optional&quot;:false,&quot;name&quot;:&quot;io.debezium.connector.mysql.Source&quot;,&quot;field&quot;:&quot;source&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;databaseName&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;ddl&quot;&#125;],&quot;optional&quot;:false,&quot;name&quot;:&quot;io.debezium.connector.mysql.SchemaChangeValue&quot;&#125;,&quot;payload&quot;:&#123;&quot;source&quot;:&#123;&quot;version&quot;:&quot;0.9.3.Final&quot;,&quot;connector&quot;:&quot;mysql&quot;,&quot;name&quot;:&quot;dbserver1&quot;,&quot;server_id&quot;:223344,&quot;ts_sec&quot;:1561364540,&quot;gtid&quot;:null,&quot;file&quot;:&quot;mysql-bin.000006&quot;,&quot;pos&quot;:22530,&quot;row&quot;:0,&quot;snapshot&quot;:false,&quot;thread&quot;:null,&quot;db&quot;:null,&quot;table&quot;:null,&quot;query&quot;:null&#125;,&quot;databaseName&quot;:&quot;inventory&quot;,&quot;ddl&quot;:&quot;ALTER TABLE `inventory`.`demo` \nMODIFY COLUMN `bigint_id` bigint(21) NOT NULL AFTER `id`&quot;&#125;&#125;2019-06-24 16:22:21.230 ERROR 14995 --- [pool-1-thread-1] c.example.embedded.DebeziumRecordUtils : not find op field.2019-06-24 16:22:21.231 INFO 14995 --- [pool-1-thread-1] c.e.embedded.DebeziumEmbeddedRunner : ddl语句 : ALTER TABLE `demo` MODIFY COLUMN `bigint_id` bigint(21) NOT NULL AFTER `id` DML的insert事件在inventory库中的demo新增一条记录后有如下日志记录，能查看到topic，key，payload以及dml的insert语句。结果会把数据同步到inventory_back库中的demo。 123452019-06-24 16:27:14.735 INFO 14995 --- [pool-1-thread-1] i.debezium.connector.mysql.BinlogReader : 1 records sent during previous 00:04:53.506, last recorded offset: &#123;ts_sec=1561364834, file=mysql-bin.000006, pos=23002, row=1, server_id=223344, event=2&#125;2019-06-24 16:27:14.737 INFO 14995 --- [pool-1-thread-1] c.e.embedded.DebeziumEmbeddedRunner : Publishing Topic --&gt; dbserver1.inventory.demo2019-06-24 16:27:14.737 INFO 14995 --- [pool-1-thread-1] c.e.embedded.DebeziumEmbeddedRunner : Key --&gt; &#123;&quot;schema&quot;:&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;id&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;bigint_id&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;var_name&quot;&#125;],&quot;optional&quot;:false,&quot;name&quot;:&quot;dbserver1.inventory.demo.Key&quot;&#125;,&quot;payload&quot;:&#123;&quot;id&quot;:2,&quot;bigint_id&quot;:1,&quot;var_name&quot;:&quot;老王&quot;&#125;&#125;2019-06-24 16:27:14.738 INFO 14995 --- [pool-1-thread-1] c.e.embedded.DebeziumEmbeddedRunner : Payload --&gt; &#123;&quot;schema&quot;:&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;id&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;bigint_id&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;var_name&quot;&#125;,&#123;&quot;type&quot;:&quot;int16&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_tinyint&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_char&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.Json&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_json&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_text&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.Year&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_year&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.MicroTime&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_time&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.Date&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_date&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.Timestamp&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_datetime&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.ZonedTimestamp&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_timestamp&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_blob&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_tinyblob&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_binary&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_double&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_float&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;org.apache.kafka.connect.data.Decimal&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;scale&quot;:&quot;2&quot;,&quot;connect.decimal.precision&quot;:&quot;10&quot;&#125;,&quot;field&quot;:&quot;ex_decimal&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;org.apache.kafka.connect.data.Decimal&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;scale&quot;:&quot;4&quot;,&quot;connect.decimal.precision&quot;:&quot;10&quot;&#125;,&quot;field&quot;:&quot;ex_numeric&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_real&quot;&#125;,&#123;&quot;type&quot;:&quot;boolean&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_bit&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.Enum&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;allowed&quot;:&quot;123,22&quot;&#125;,&quot;default&quot;:&quot;123&quot;,&quot;field&quot;:&quot;ex_enum&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.EnumSet&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;allowed&quot;:&quot;a,b,c,d&quot;&#125;,&quot;field&quot;:&quot;ex_set&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_geometry&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;x&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;y&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Point&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry (POINT)&quot;,&quot;field&quot;:&quot;ex_point&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_linestring&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_polygon&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_geometrycollection&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_multipoint&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;dbserver1.inventory.demo.Value&quot;,&quot;field&quot;:&quot;before&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;id&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;bigint_id&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;var_name&quot;&#125;,&#123;&quot;type&quot;:&quot;int16&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_tinyint&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_char&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.Json&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_json&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_text&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.Year&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_year&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.MicroTime&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_time&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.Date&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_date&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.Timestamp&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_datetime&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.time.ZonedTimestamp&quot;,&quot;version&quot;:1,&quot;field&quot;:&quot;ex_timestamp&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_blob&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_tinyblob&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_binary&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_double&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_float&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;org.apache.kafka.connect.data.Decimal&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;scale&quot;:&quot;2&quot;,&quot;connect.decimal.precision&quot;:&quot;10&quot;&#125;,&quot;field&quot;:&quot;ex_decimal&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;org.apache.kafka.connect.data.Decimal&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;scale&quot;:&quot;4&quot;,&quot;connect.decimal.precision&quot;:&quot;10&quot;&#125;,&quot;field&quot;:&quot;ex_numeric&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_real&quot;&#125;,&#123;&quot;type&quot;:&quot;boolean&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ex_bit&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.Enum&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;allowed&quot;:&quot;123,22&quot;&#125;,&quot;default&quot;:&quot;123&quot;,&quot;field&quot;:&quot;ex_enum&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.EnumSet&quot;,&quot;version&quot;:1,&quot;parameters&quot;:&#123;&quot;allowed&quot;:&quot;a,b,c,d&quot;&#125;,&quot;field&quot;:&quot;ex_set&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_geometry&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;x&quot;&#125;,&#123;&quot;type&quot;:&quot;double&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;y&quot;&#125;,&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Point&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry (POINT)&quot;,&quot;field&quot;:&quot;ex_point&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_linestring&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_polygon&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_geometrycollection&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;bytes&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;wkb&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;srid&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;io.debezium.data.geometry.Geometry&quot;,&quot;version&quot;:1,&quot;doc&quot;:&quot;Geometry&quot;,&quot;field&quot;:&quot;ex_multipoint&quot;&#125;],&quot;optional&quot;:true,&quot;name&quot;:&quot;dbserver1.inventory.demo.Value&quot;,&quot;field&quot;:&quot;after&quot;&#125;,&#123;&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;version&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;connector&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;server_id&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;ts_sec&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;gtid&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;file&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;pos&quot;&#125;,&#123;&quot;type&quot;:&quot;int32&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;row&quot;&#125;,&#123;&quot;type&quot;:&quot;boolean&quot;,&quot;optional&quot;:true,&quot;default&quot;:false,&quot;field&quot;:&quot;snapshot&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;thread&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;db&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;table&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;query&quot;&#125;],&quot;optional&quot;:false,&quot;name&quot;:&quot;io.debezium.connector.mysql.Source&quot;,&quot;field&quot;:&quot;source&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false,&quot;field&quot;:&quot;op&quot;&#125;,&#123;&quot;type&quot;:&quot;int64&quot;,&quot;optional&quot;:true,&quot;field&quot;:&quot;ts_ms&quot;&#125;],&quot;optional&quot;:false,&quot;name&quot;:&quot;dbserver1.inventory.demo.Envelope&quot;&#125;,&quot;payload&quot;:&#123;&quot;before&quot;:null,&quot;after&quot;:&#123;&quot;id&quot;:2,&quot;bigint_id&quot;:1,&quot;var_name&quot;:&quot;老王&quot;,&quot;ex_tinyint&quot;:1,&quot;ex_char&quot;:&quot;a&quot;,&quot;ex_json&quot;:&quot;&#123;\&quot;abc\&quot;:123&#125;&quot;,&quot;ex_text&quot;:&quot;ert&quot;,&quot;ex_year&quot;:2019,&quot;ex_time&quot;:59224000000,&quot;ex_date&quot;:null,&quot;ex_datetime&quot;:null,&quot;ex_timestamp&quot;:null,&quot;ex_blob&quot;:null,&quot;ex_tinyblob&quot;:null,&quot;ex_binary&quot;:null,&quot;ex_double&quot;:null,&quot;ex_float&quot;:null,&quot;ex_decimal&quot;:null,&quot;ex_numeric&quot;:null,&quot;ex_real&quot;:null,&quot;ex_bit&quot;:null,&quot;ex_enum&quot;:&quot;123&quot;,&quot;ex_set&quot;:null,&quot;ex_geometry&quot;:null,&quot;ex_point&quot;:null,&quot;ex_linestring&quot;:null,&quot;ex_polygon&quot;:null,&quot;ex_geometrycollection&quot;:null,&quot;ex_multipoint&quot;:null&#125;,&quot;source&quot;:&#123;&quot;version&quot;:&quot;0.9.3.Final&quot;,&quot;connector&quot;:&quot;mysql&quot;,&quot;name&quot;:&quot;dbserver1&quot;,&quot;server_id&quot;:223344,&quot;ts_sec&quot;:1561364834,&quot;gtid&quot;:null,&quot;file&quot;:&quot;mysql-bin.000006&quot;,&quot;pos&quot;:23194,&quot;row&quot;:0,&quot;snapshot&quot;:false,&quot;thread&quot;:9,&quot;db&quot;:&quot;inventory&quot;,&quot;table&quot;:&quot;demo&quot;,&quot;query&quot;:null&#125;,&quot;op&quot;:&quot;c&quot;,&quot;ts_ms&quot;:1561364834477&#125;&#125;2019-06-24 16:27:14.738 INFO 14995 --- [pool-1-thread-1] c.e.embedded.DebeziumEmbeddedRunner : dml语句 : insert into demo values (:id,:bigint_id,:var_name,:ex_tinyint,:ex_char,:ex_json,:ex_text,:ex_year,:ex_time,:ex_date,:ex_datetime,:ex_timestamp,:ex_blob,:ex_tinyblob,:ex_binary,:ex_double,:ex_float,:ex_decimal,:ex_numeric,:ex_real,:ex_bit,:ex_enum,:ex_set,:ex_geometry,:ex_point,:ex_linestring,:ex_polygon,:ex_geometrycollection,:ex_multipoint) DML的update事件在inventory库中的demo修改刚刚新增的记录后有如下日志记录，能查看到topic，key，payload以及先delete再insert语句。结果会把数据同步到inventory_back库中的demo。 DML的delete事件在inventory库中的demo修改刚刚修改的记录给删除掉后有如下日志记录，能查看到topic，key，payload以及先delete语句。结果会把数据同步到inventory_back库中的demo将其删掉。这里有2个事件，第二条事件是一种标致，这里不处理。 日志： 参考debezium官网 Tutorial Embedding Debezium]]></content>
      <categories>
        <category>数据同步</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>cdc</tag>
        <tag>debezium</tag>
        <tag>kafka</tag>
        <tag>connector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对xxl-job进行simpleTrigger并动态创建任务扩展]]></title>
    <url>%2F2019%2F05%2F08%2Fxxl-job-simple-trigger%2F</url>
    <content type="text"><![CDATA[业务场景需求上要求能实现quartz的simpleTrigger任务，同时还需要动态的创建任务而非在控制面板上创建，查阅xxl-job官方文档发现simpelTrigger其暂时还躺在to do list，而动态创建可以调用JobInfoController其add和start接口(但是有个弊端，start/stop/remove等方法都只要求传送id，这点上可以自己扩展接口实现)，还需要放开登录权限，接下来就老夫上去就上一梭子，开干。 job_info字段调整说明123456789101112131415161718192021222324252627CREATE TABLE `XXL_JOB_QRTZ_TRIGGER_INFO` ( `id` int(11) NOT NULL AUTO_INCREMENT, `job_group` int(11) NOT NULL COMMENT '执行器主键ID', `job_cron` varchar(128) DEFAULT NULL COMMENT '任务执行CRON', `job_desc` varchar(255) NOT NULL, `add_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, `author` varchar(64) DEFAULT NULL COMMENT '作者', `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件', `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略', `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler', `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数', `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略', `executor_timeout` int(11) NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒', `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数', `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型', `glue_source` mediumtext COMMENT 'GLUE源代码', `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注', `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间', `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔', `ext_reamrk` varchar(255) DEFAULT NULL, `job_start_time` bigint(20) DEFAULT NULL COMMENT 'trigger开始时间于当前时间的时间间隔 单位毫秒\n', `job_end_time` datetime DEFAULT NULL COMMENT 'trigger结束时间', `job_repeat_count` bigint(7) DEFAULT '-1' COMMENT 'simple_trigger 执行次数 ', `job_repeat_interval` bigint(12) DEFAULT NULL COMMENT 'simple_trigger 时间间隔 单位毫秒', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; job_cron设为空，支持simpleTrigger； ext_reamrk自定义扩展字段，可以根据它来刷选job从而避免start/stop/remove接口只有id作为参数； job_repeat_count，simplerTrigger的执行次数，默认-1即为无限次，0的话是执行1次； job_repeat_interval，simplerTrigger每次执行的时间间隔，单位毫秒； job_start_time，trigger开始时间和当前时间的时间间隔，单位毫秒； job_end_time，trigger结束时间 重写启动任务xxl-job在新建任务的时候只是把job数据保存到数据库里，只有启动的时候才会创建jobDetail和trigger并由scheduler来启动job。 重写XxlJobDynamicScheduler的addJob方法：根据jobInfo中的值构建cron的trigger还是simple的trigger。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static boolean addJob(XxlJobInfo xxlJobInfo) throws SchedulerException &#123; String jobName = String.valueOf(xxlJobInfo.getId()); String cronExpression = xxlJobInfo.getJobCron(); Integer jobRepeatCount = xxlJobInfo.getJobRepeatCount(); Long jobRepeatInterval = xxlJobInfo.getJobRepeatInterval(); // 1、job key TriggerKey triggerKey = TriggerKey.triggerKey(jobName); JobKey jobKey = new JobKey(jobName); // 2、valid trigger if(scheduler.checkExists(triggerKey)) &#123; return true; &#125; // 3.1、corn trigger Trigger trigger = null; if (!StringUtils.isEmpty(cronExpression)) &#123; CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(cronExpression).withMisfireHandlingInstructionDoNothing(); // withMisfireHandlingInstructionDoNothing 忽略掉调度终止过程中忽略的调度 TriggerBuilder&lt;CronTrigger&gt; builder = TriggerBuilder.newTrigger().withIdentity(triggerKey) .withSchedule(cronScheduleBuilder) .endAt(xxlJobInfo.getJobEndTime()); Optional.ofNullable(xxlJobInfo.getJobStartTime()) .ifPresent(start -&gt; builder.startAt(new Date(System.currentTimeMillis() + start))); trigger = builder.build(); &#125; else // 3.2、simple trigger if (Objects.nonNull(jobRepeatInterval) &amp;&amp; Objects.nonNull(jobRepeatCount)) &#123; SimpleScheduleBuilder simpleScheduleBuilder = SimpleScheduleBuilder.simpleSchedule() .withIntervalInMilliseconds(jobRepeatInterval) .withRepeatCount(jobRepeatCount); TriggerBuilder&lt;SimpleTrigger&gt; builder = TriggerBuilder.newTrigger().withIdentity(triggerKey) .withSchedule(simpleScheduleBuilder) .endAt(xxlJobInfo.getJobEndTime()); Optional.ofNullable(xxlJobInfo.getJobStartTime()) .ifPresent(start -&gt; builder.startAt(new Date(System.currentTimeMillis() + start))); trigger = builder.build(); &#125; // 3.3、valid trigger if(Objects.isNull(trigger)) &#123; return true; &#125; // 4、job detail Class&lt;? extends Job&gt; jobClass_ = RemoteHttpJobBean.class; // Class.forName(jobInfo.getJobClass()); JobDetail jobDetail = JobBuilder.newJob(jobClass_).withIdentity(jobKey).build(); /*if (jobInfo.getJobData()!=null) &#123; JobDataMap jobDataMap = jobDetail.getJobDataMap(); jobDataMap.putAll(JacksonUtil.readValue(jobInfo.getJobData(), Map.class)); // JobExecutionContext context.getMergedJobDataMap().get("mailGuid"); &#125;*/ // 5、schedule job Date date = scheduler.scheduleJob(jobDetail, trigger); logger.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addJob success(quartz), jobDetail:&#123;&#125;, trigger:&#123;&#125;, date:&#123;&#125;", jobDetail, trigger, date); return true; &#125; 效果图 可以看到将数据库里3任务改为间隔3秒，job_repeat_count为1，任务实际会执行2次。 额外的工作 虽然支持cron或simple，但是在控制台节目只能维护cron的trigger，并且优先cron，同时cron设为可以为空，但是管理平台上没有simple的相关数据，如果需要的话要重新修改对应的页面和add和update的逻辑； job状态取的是trigger的状态，所以可能看到的是simpleTrigger的状态。 目前job的trigger是在cron和simple中二者取一，但是也可以扩展启动任务的方法，使其支持扩展多trigger，但是triggerKey需要重新定义而非取jobName（因为trigger的hash是triggerKey的hash），本身xxl-job的jobKey取的是job的id，triggerKey取的也是job的id，没有使用到groupName。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之单例模式]]></title>
    <url>%2F2019%2F04%2F02%2Fdesign-pattern-singleton%2F</url>
    <content type="text"><![CDATA[单例模式Ensure a class has only one instance, and provide a global point of access to it.一个类仅仅只有一个实例，并且提供全局的接入点。简洁点理解就是涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问它自己唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 饿汉式单例模式1234567891011public final class EagerSingleton &#123; private static final EagerSingleton INSTANCE = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return INSTANCE; &#125;&#125; 基于 classloader 机制避免了多线程的同步问题，不过INSTANCE在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法。类在加载时就初始化了，会浪费空间，因为不管你用还是不用，它都创建出来了，但是因为没有加锁，执行效率较高。 懒汉式单例模式1234567891011121314151617/** * 懒汉式的单例模式-线程不安全的 */public final class LazyThreadNotSafeSingleton &#123; private static LazyThreadNotSafeSingleton INSTANCE; private LazyThreadNotSafeSingleton() &#123; &#125; public static LazyThreadNotSafeSingleton getInstance() &#123; if (null == INSTANCE) &#123; INSTANCE = new LazyThreadNotSafeSingleton(); &#125; return INSTANCE; &#125;&#125; 1234567891011121314151617/** * 懒汉式的单例模式-线程安全的 */public final class LazyThreadSafeSingleton &#123; private static LazyThreadSafeSingleton INSTANCE; private LazyThreadSafeSingleton() &#123; &#125; public static synchronized LazyThreadSafeSingleton getInstance() &#123; if (null == INSTANCE) &#123; INSTANCE = new LazyThreadSafeSingleton(); &#125; return INSTANCE; &#125;&#125; 有上述两种懒汉式单例模式，区别在与静态工厂方法getInstance是否加了synchronized修饰来进行同步，用于支持线程安全。懒汉式，在其加载对象的时候是不会创建对象实例的，只有等它真正使用的时候才会创建，如果一直没有使用则一直不会创建，能够避免内存浪费，也就是只有第一次调用的时候才会创建。但是加锁synchronized就影响了性能和效率，导致getInstance方法的性能受影响，此种方式也不推荐。寻找一种既能线程安全又可以延迟加载的方式。 双检查锁的单例模式123456789101112131415161718192021222324/** * 双检查锁的单例模式-线程安全 */public final class DoubleCheckLockingSingleton &#123; private static volatile DoubleCheckLockingSingleton INSTANCE; private DoubleCheckLockingSingleton() &#123; &#125; public static DoubleCheckLockingSingleton getInstance() &#123; // 第一次检查实例是否存在，如果存在即可返回，不存在则进入同步块 if (null == INSTANCE) &#123; // 同步块，线程安全 synchronized (DoubleCheckLockingSingleton.class) &#123; // 第二次检查实例是否存在，如果还不存在则会真正的创建实例 if (null == INSTANCE) &#123; INSTANCE = new DoubleCheckLockingSingleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 双检查加锁的方式，能实现线程安全，又能减少性能的影响。双检查加锁，旨在每次调用getInstance方法都需要同步，但是先不会同步，在第一次判断实例是否存在后，如果不存在才进入同步块，进入同步块后，第二次检查实例是否存在，如果不存在，在同步块内创建实例。如此只有首次才会同步，从而减少了多次在同步情况下进行判断所浪费的时间。双检查加锁机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。但是实现过程稍微复杂点。 静态内部类Holder式单例模式12345678910111213141516171819202122/** * 静态内部类Holder式单例 * * 延迟加载和线程安全 */public final class LazyInitializationHolderSingleton &#123; private LazyInitializationHolderSingleton() &#123; &#125; public static LazyInitializationHolderSingleton getInstance() &#123; return InstanceHolder.INSTANCE; &#125; /** * 延迟加载 */ private static class InstanceHolder &#123; private static final LazyInitializationHolderSingleton INSTANCE = new LazyInitializationHolderSingleton(); &#125;&#125; 当getInstance方法第一次被调用的时候，它第一次读取InstanceHolder.INSTANCE，导致InstanceHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。其中使用到类的静态内部类和多线程缺省同步锁。 静态内部类 静态内部类指，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。静态内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。静态内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。 多线程缺省同步锁 在多线程开发中，为解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括： 1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时； 2.访问final字段时； 3.在创建线程之前创建对象时； 4.线程可以看见它将要处理的对象时 枚举类型的单例模式1234567891011121314151617/** * 采用枚举类型的单例模式 */public enum SingletonEnum &#123; INSTANCE; @Override public String toString() &#123; return getDeclaringClass().getCanonicalName() + "@" + hashCode(); &#125; public void something()&#123; //do something... &#125;&#125; 简洁，自动支持序列化机制，绝对防止多次实例化。《高效Java 第二版》中的说法：单元素的枚举类型已经成为实现Singleton的最佳方法。用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。 总结不建议使用懒汉式，简单的阔以使用饿汉式。涉及到反序列化创建对象时阔以使用枚举方式。如果考虑到延迟加载 的话，阔以采用静态内部类Holder的模式。如果对业务需求有特殊要求的时候阔以采用双检查锁的单例。 参考源码地址 单例模式|菜鸟教程 《JAVA与模式》之单例模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之建造者模式]]></title>
    <url>%2F2019%2F03%2F29%2Fdesign-pattern-builder%2F</url>
    <content type="text"><![CDATA[建造者模式Separate the construction of a complex object from its representation, allowing the same construction process to create various representations.将复杂对象的构造与其表现分离，允许相同的构造过程用来创建不同的表现。通俗点就是，一个对象创建过程很复杂，我们将其每项元素创建过程抽离出来，通过相同的构造过程可以构造出不用的对象。还不懂可以看到如下的UML图。 建造者模式UML图 此AbstractPersonBuilder就是如上的相同的构造，而不同的表现就是此处的PersonOneBuilder和PersonTwoBuilder两个相同方式的构造器，但是具体的实现是不一样而构造出不同的表现。所以就是相同的构造过程而构造出不同的对象。 建造者模式角色抽象建造者(AbstractPersonBuilder或者Builder)：抽象类或者接口，复杂对象的属性的抽象方法，并不涉及具体的对象部件的创建； 具体建造者(PersonOneBuilder和PersonTwoBuilder)：实现抽象建造者，针对不同的业务，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例； 指挥者(Director)：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建； 具体的产品(Person)：需创建的复杂对象； 建造者模式源码干货源码地址：请点击我 在这里我分为三种情况讲讲建造者模式，第一种是我们最原始的建造者模式来构建，第二种是我们在实体对象时会使用的，第三种是我们平常对实体对象最常规使用方法借助lombok。 第一种建造者模式使用的真是上面按照角色来建造的方式，稍微比如下的两种方法负责点。 AbstractPersonBuilderPersonOneBuilderPersonTwoBuilder抽象建造者 123456789101112131415public abstract class AbstractPersonBuilder &#123;​ protected Person product = new Person();​ public abstract void buildName();​ public abstract void buildAge();​ public abstract void buildChildren();​ public Person build() &#123;​ return product;​ &#125;&#125;第一个具体建造者 123456789101112131415public class PersonOneBuilder extends AbstractPersonBuilder &#123;​ public void buildName() &#123;​ product.setName(“老one”);​ &#125;​ public void buildAge() &#123;​ product.setAge(44);​ &#125;​ public void buildChildren() &#123;​ product.setChildren(Lists.newArrayList(“小one”));​ &#125;&#125;第二个具体建造者 123456789101112131415public class PersonTwoBuilder extends AbstractPersonBuilder &#123;​ public void buildName() &#123;​ product.setName(“老two”);​ &#125;​ public void buildAge() &#123;​ product.setAge(55);​ &#125;​ public void buildChildren() &#123;​ product.setChildren(Lists.newArrayList(“小two”));​ &#125;&#125; ApplicationPersonDirector示例 12345678910111213@Slf4jpublic class Application &#123;​ public static void main(String[] args) &#123;​ Director director = new Director(new PersonOneBuilder());​ Person person = director.construct();​ log.info(“person的信息：&#123;&#125;”, person);​ director.setBuilder(new PersonTwoBuilder());​ person = director.construct();​ log.info(“person的信息：&#123;&#125;”, person);​ &#125;&#125;Person类充当产品数据 1234567891011121314151617181920212223242526272829303132333435363738394041public class Person &#123;​ private String name;​ private int age;​ private List&lt;String&gt; children;​ @Override​ public String toString() &#123;​ return “Person&#123;” +​ “name=’” + name + ‘\’’ +​ “, age=” + age +​ “, children=” + children +​ ‘&#125;’;​ &#125;​ public String getName() &#123;​ return name;​ &#125;​ public void setName(String name) &#123;​ this.name = name;​ &#125;​ public int getAge() &#123;​ return age;​ &#125;​ public void setAge(int age) &#123;​ this.age = age;​ &#125;​ public List&lt;String&gt; getChildren() &#123;​ return children;​ &#125;​ public void setChildren(List&lt;String&gt; children) &#123;​ this.children = children;​ &#125;&#125;指挥者，指定具体的建造者用来建造对象 12345678910111213141516171819public class Director &#123;​ private AbstractPersonBuilder builder;​ public Director(AbstractPersonBuilder builder) &#123;​ this.builder = builder;​ &#125;​ public void setBuilder(AbstractPersonBuilder builder) &#123;​ this.builder = builder;​ &#125;​ public Person construct() &#123;​ builder.buildName();​ builder.buildAge();​ builder.buildChildren();​ return builder.build();​ &#125;&#125; 结果： 第二种建造者模式第二种方式比上面那种简单些，因为我们只指定了一种构造方式，并且还可以借用第三方工具IDEA+Plugins。 在IDEA中可以搜索 使用方法： 1.找到对应需要添加bulid的类通过自动生成快捷键可以查看到build 2.根据自己的风格可以定义bulid的名字，各个bulid方法的前缀以及包名，具体bulider如下代码中。 ApplicationPersonPersonBuilder示例 123456789101112@Slf4jpublic class Application &#123;​ public static void main(String[] args) &#123;​ Person wang = PersonBuilder.builder()​ .withAge(40)​ .withName(“老王”)​ .withChildren(Lists.newArrayList(“李一一”, “吴老三”))​ .build();​ log.info(“老王的信息：&#123;&#125;”, wang);​ &#125;&#125;Person类充当产品数据 1234567891011121314151617181920212223242526272829303132333435363738394041public class Person &#123;​ private String name;​ private int age;​ private List&lt;String&gt; children;​ @Override​ public String toString() &#123;​ return “Person&#123;” +​ “name=’” + name + ‘\’’ +​ “, age=” + age +​ “, children=” + children +​ ‘&#125;’;​ &#125;​ public String getName() &#123;​ return name;​ &#125;​ public void setName(String name) &#123;​ this.name = name;​ &#125;​ public int getAge() &#123;​ return age;​ &#125;​ public void setAge(int age) &#123;​ this.age = age;​ &#125;​ public List&lt;String&gt; getChildren() &#123;​ return children;​ &#125;​ public void setChildren(List&lt;String&gt; children) &#123;​ this.children = children;​ &#125;&#125;PersonBuilder用来Person的构建者 1234567891011121314151617181920212223242526272829303132333435public final class PersonBuilder &#123; private String name; private int age; private List&lt;String&gt; children;​ private PersonBuilder() &#123;​ &#125;​ public static PersonBuilder builder() &#123;​ return new PersonBuilder();​ &#125;​ public PersonBuilder withName(String name) &#123;​ this.name = name;​ return this;​ &#125;​ public PersonBuilder withAge(int age) &#123;​ this.age = age;​ return this;​ &#125;​ public PersonBuilder withChildren(List&lt;String&gt; children) &#123;​ this.children = children;​ return this;​ &#125;​ public Person build() &#123;​ Person person = new Person();​ person.setName(name);​ person.setAge(age);​ person.setChildren(children);​ return person;​ &#125;&#125; 结果如下： 第三种建造者模式第三种模式相对来说就简单非常多，因为我们借用的是lombok的@Builder注解。lombok在18.2版本中引入了@SuperBulider注解用来解决@Builder类的继承不生效的问题。详细的使用阔以看我上篇文章 折腾Java设计模式之模板方法模式 12345678910111213@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private String name; private int age; private List&lt;String&gt; children;&#125; 123456789101112@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Person wang = Person.builder() .age(40) .name("老王") .children(Lists.newArrayList("李一一", "吴老三")) .build(); log.info("老王的信息：&#123;&#125;", wang); &#125;&#125; 结果： 总结第二、三种模式在我们经常操作像对VO、DO、DTO对象时，常用如此定义。第一种标准的建造者模式，其实本身指挥者这个角色是不关心具体的产品实现的，相对于是一种解耦，对于如果新增一种建造者实现，可以方便扩展，符合开闭原则，但是无独有偶，实现了上述优点后，但是缺点也跟着来，新增了很多类，维护成本高，如果建造者内部发生变更，就不太适合建造者这种模式了。总体而言还是有很多使用场景的。像StringBulider其实也是一种。像之前在spring-boot的spring-cache中的扩展redis缓存的ttl和key名这篇文章中定义的RedisCacheManagerBuilder，以及我们常用的以后要讲的Feign的Builder等等。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之模板方法模式]]></title>
    <url>%2F2019%2F03%2F11%2Fdesign-pattern-template-method%2F</url>
    <content type="text"><![CDATA[模板方法模式Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.翻译过来就是，把算法的框架定义好，可以将某些步抽象出来放到子类去实现。模板方法允许子类在不改变算法框架的情况下重新实现算法的某些步骤。 模板方法模式UML图UML图 抽象类AbstractClass定义了算法框架templateMethod()方法，其中有2个方法primitve1()和primitve2()被抽象出来，子类SubClass1继承了抽象类AbstractClass，从而实现了primitve1()和primitve2()。 模板方法模式角色抽象类(AbstractClass)： 定义了算法核心框架，同时把局部的算法行为封装成步骤，让子类去实现。 子类(SubClass): 继承了抽象类，实现抽象类中的抽象方法，具体实现了算法部分逻辑。 模板方法模式源码示例源码地址：Template-method 抽象方法先定义抽象类，抽象类AbstractProcessor中核心算法handle方法中大体分3部，第一先校验参数具体怎么校验放在子类中实现，第二获取结果也放在子类实现，第三获取结果后的操作也放在子类实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Slf4jpublic abstract class AbstractProcessor&lt;P extends Request, R extends Response&gt; &#123; /** * 逻辑处理 * * @param request * @return */ public R handle(P request) &#123; // 1.校验参数 log.info("开始处理, 请求参数=&#123;&#125;", request); validRequest(request); // 2.获取结果 R response = getResponse(request); log.info("获取结果, 响应结果=&#123;&#125;", response); // 3.结果之后的处理 afterHandle(response); return response; &#125; /** * 结果之后的处理 可以更新其他业务或者处理缓存 * * @param response */ protected abstract void afterHandle(R response); /** * 校验请求参数 * * @param request */ protected void validRequest(P request) &#123; if (Objects.isNull(request.getToken())) &#123; throw new RuntimeException("token不能为空"); &#125; if (Objects.isNull(request.getVersion())) &#123; throw new RuntimeException("version不能为空"); &#125; validRequestParam(request); &#125; /** * 校验请求真正的参数 * @param request */ protected abstract void validRequestParam(P request); /** * 获取到结果 * @param request * @return */ protected abstract R getResponse(P request);&#125; RequestResponse基本请求 12345678910@Data@SuperBuilder@NoArgsConstructor@AllArgsConstructorpublic class Request &#123;​ private String version;​ private String token;&#125;基本响应 12345678910111213@Data@SuperBuilder@NoArgsConstructor@AllArgsConstructorpublic class Response &#123;​ private String msg;​ private int code;​ private boolean success;&#125; 子类实现OneProcessorOneRequestOneResponse第一个子类实现 12345678910111213141516171819202122232425262728@Slf4jpublic class OneProcessor extends AbstractProcessor&lt;OneRequest, OneResponse&gt; &#123;​ public OneProcessor() &#123;​ ProcessorFactory.putProcess(“two”, this);​ &#125;​ @Override​ protected void afterHandle(OneResponse response) &#123;​ log.info(“处理One结果： &#123;&#125;”, response.getOne());​ &#125;​ @Override​ protected void validRequestParam(OneRequest request) &#123;​ log.info(“校验one参数…省略……”);​ &#125;​ @Override​ protected OneResponse getResponse(OneRequest request) &#123;​ String name = request.getName();​ return OneResponse.builder()​ .one(name + “one”)​ .success(true)​ .code(0)​ .msg(“成功”)​ .build();​ &#125;&#125;第一个子类的请求 12345678910111213@Data@ToString(callSuper = true)@SuperBuilder@NoArgsConstructor@AllArgsConstructorpublic class OneRequest extends Request &#123;​ private String name;​ @Builder.Default​ private int a = 0;&#125;第一个子类的响应 12345678910@Data@ToString(callSuper = true)@SuperBuilder@NoArgsConstructor@AllArgsConstructorpublic class OneResponse extends Response &#123;​ private String one;&#125; OneProcessorTwoRequestTwoResponse第二个子类实现 12345678910111213141516171819202122232425262728@Slf4jpublic class TwoProcessor extends AbstractProcessor&lt;TwoRequest, TwoResponse&gt; &#123;​ public TwoProcessor() &#123;​ ProcessorFactory.putProcess(“two”, this);​ &#125;​ @Override​ protected void afterHandle(TwoResponse response) &#123;​ log.info(“处理结果TWO, &#123;&#125;”, response);​ &#125;​ @Override​ protected void validRequestParam(TwoRequest request) &#123;​ log.info(“校验TWO参数…省略……”);​ &#125;​ @Override​ protected TwoResponse getResponse(TwoRequest request) &#123;​ Long id = request.getId();​ return TwoResponse.builder()​ .two(“id为”+id)​ .success(true)​ .code(0)​ .msg(“成功”)​ .build();​ &#125;&#125;第二个子类的请求 123456789@Data@ToString(callSuper = true)@SuperBuilder@NoArgsConstructor@AllArgsConstructorpublic class TwoRequest extends Request &#123;​ private Long id;&#125;第二个子类的响应 123456789@Data@ToString(callSuper = true)@SuperBuilder@NoArgsConstructor@AllArgsConstructorpublic class TwoResponse extends Response &#123;​ private String two;&#125; 扩展为工厂有的时候我们定义的子类在Spring容器的时候由Spring定义好后，我们其实可以借用工厂模式方法，在子类初始化的时候就把子类放置在ProcessorFactory中，后续只需要根据key从中拿取即可，实际项目中用这种方式还是比较多的。 12345678910111213public class ProcessorFactory &#123; private static Map&lt;String, AbstractProcessor&gt; factories = new HashMap(); public static void putProcess(String key, AbstractProcessor process) &#123; factories.put(key, process); &#125; public static AbstractProcessor selectProcess(String key) &#123; return factories.get(key); &#125;&#125; 执行程序1234567891011121314151617181920212223@Slf4jpublic class TemplateMethodApplication &#123; public static void main(String[] args) &#123; OneRequest oneRequest = OneRequest.builder() .version("2312312") .token("23423") .name("张三") .build(); new OneProcessor().handle(oneRequest); log.info("--------------------------"); TwoRequest twoRequest = TwoRequest.builder() .version("2312312") .token("23423") .id(23456L) .build(); new TwoProcessor().handle(twoRequest); &#125;&#125; 结果 总体上来讲，抽象类中定义了算法的框架，然后把部分算法步骤抽象出来供子类实现，有的时候有些方法只有个别子类会去实现，我们可以在抽象类中实现为空实现，在有需要的子类中我们可以覆盖抽象类的实现，这样避免了所有的子类都去实现，其实不关心的话都是空实现了。本示例用到了lombok的@SuperBuilder特性，可能在下载完完整的代码后会出现编译错误，这是因为Lombok的插件暂时还不支持@SuperBuilder。 模板方法模式总结模板方法经常和其他模式混合使用，比如工厂、策略等等。其实在Spring中大量使用了模板方法模式，其实也不光在Spring中，像平时jdbcTemplate或者RedisTemplate，像这种带有Template的。 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。 注意事项： 为防止恶意操作，一般模板方法都加上 final 关键词。 参考模板模式|菜鸟教程 Template method pattern]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot的spring-cache中的扩展redis缓存的ttl和key名]]></title>
    <url>%2F2019%2F01%2F31%2Fspring-boot-redis-cache-ext%2F</url>
    <content type="text"><![CDATA[前提spring-cache大家都用过，其中使用redis-cache大家也用过，至于如何使用怎么配置，本篇就不重点描述了。本篇主要解决2个问题，第一个问题使用redis做缓存时对每个key进行自定义的过期时间配置，第二个使用redis做缓存时@Cacheable(value = &quot;value&quot;, key = &quot;#p0&quot;) ，最后生成的key会在value和p0中间的有(::)2个冒号，与redis的key名一个冒号间隔的风格不符。 本篇以spring-boot 2.1.2和 spirng 5.1.4为基础来讲解。RedisCacheManage在spring-data-redis 2.x中相对于1.x的变动很大，本篇即在2.x的版本中实现。 redis cache的过期时间我们都知道redis的过期时间，是用它做缓存或者做业务操作的灵性。在使用@Cacheable(value = &quot;value&quot;, key = &quot;#p0&quot;)注解时即可。具体的使用方法参考网上。 RedisCacheManagerRedisCacheConfiguration我们先来看看RedisCacheManager，RedisCacheWriter接口是对redis操作进行包装的一层低级的操作。defaultCacheConfig是redis的默认配置，在下一个选项卡中详细介绍。initialCacheConfiguration是对各个单独的缓存进行各自详细的配置(过期时间就是在此配置的)，allowInFlightCacheCreation是否允许创建不事先定义的缓存，如果不存在即使用默认配置。RedisCacheManagerBuilder使用桥模式，我们可以用它构建RedisCacheManager。 1234567891011public class RedisCacheManager extends AbstractTransactionSupportingCacheManager &#123; private final RedisCacheWriter cacheWriter; private final RedisCacheConfiguration defaultCacheConfig; private final Map&lt;String, RedisCacheConfiguration&gt; initialCacheConfiguration; private final boolean allowInFlightCacheCreation; public static class RedisCacheManagerBuilder &#123;&#125;&#125; AbstractTransactionSupportingCacheManager加入事务概念，将操作与事务绑定，包装了一层事务。 1234567891011121314151617181920public abstract class AbstractTransactionSupportingCacheManager extends AbstractCacheManager &#123; private boolean transactionAware = false; public void setTransactionAware(boolean transactionAware) &#123; this.transactionAware = transactionAware; &#125; public boolean isTransactionAware() &#123; return this.transactionAware; &#125; @Override protected Cache decorateCache(Cache cache) &#123; return (isTransactionAware() ? new TransactionAwareCacheDecorator(cache) : cache); &#125;&#125;ttl是过期时间，cacheNullValues是否允许存null值，keyPrefix缓存前缀规则，usePrefix是否允许使用前缀。keySerializationPair缓存key序列化，valueSerializationPair缓存值序列化此处最好自己使用jackson的序列号替代原生的jdk序列化，conversionService做转换用的。 123456789101112131415public class RedisCacheConfiguration &#123; private final Duration ttl; private final boolean cacheNullValues; private final CacheKeyPrefix keyPrefix; private final boolean usePrefix; private final SerializationPair&lt;String&gt; keySerializationPair; private final SerializationPair&lt;Object&gt; valueSerializationPair; private final ConversionService conversionService;&#125; 再来看看如何配置RedisCacheManager RedisCacheAutoConfigurationCustomCachePropertiesyml配置配置前通过RedisAutoConfiguration配置可以获取到redis相关配置包括redisTemplate，因为spring-boot2中redis使用Lettuce作为客户端，相关配置在LettuceConnectionConfiguration中。 在去加载CacheProperties和CustomCacheProperties配置。 通过RedisCacheManagerBuilder去构造RedisCacheManager，使用非加锁的redis缓存操作，redis默认配置使用的是cacheProperties中的redis，最后根据我们自定义的customCacheProperties阔以针对单个的key设置单独的redis缓存配置，详情阔以查看。 getDefaultRedisCacheConfiguration主要先通过RedisCacheConfiguration的默认创建方法defaultCacheConfig创建默认的配置，在通过getJackson2JsonRedisSerializer创建默认value格式化(使用jackson代替jdk序列化)，然后通过redis缓存配置的是spring-cache的CacheProperties去修改配置项。 最后根据配置构建出RedisCacheConfiguration。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Slf4j@EnableCaching@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)@EnableConfigurationProperties(&#123;CacheProperties.class, CustomCacheProperties.class&#125;)@ConditionalOnClass(&#123;Redis.class, RedisCacheConfiguration.class&#125;)public class RedisCacheAutoConfiguration &#123;​ @Autowired​ private CacheProperties cacheProperties;​ @Bean​ public RedisCacheManager redisCacheManager(CustomCacheProperties customCacheProperties,​ RedisConnectionFactory redisConnectionFactory) &#123;​ RedisCacheConfiguration defaultConfiguration = getDefaultRedisCacheConfiguration();​ RedisCacheManager.RedisCacheManagerBuilder builder = RedisCacheManager.RedisCacheManagerBuilder​ .fromCacheWriter(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory))​ .cacheDefaults(defaultConfiguration);​ Map&lt;String, RedisCacheConfiguration&gt; map = Maps.newHashMap();​ Optional.ofNullable(customCacheProperties)​ .map(p -&gt; p.getCustomCache())​ .ifPresent(customCache -&gt; &#123;​ customCache.forEach((key, cache) -&gt; &#123;​ RedisCacheConfiguration cfg = handleRedisCacheConfiguration(cache, defaultConfiguration);​ map.put(key, cfg);​ &#125;);​ &#125;);​ builder.withInitialCacheConfigurations(map);​ return builder.build();​ &#125;​ private RedisCacheConfiguration getDefaultRedisCacheConfiguration() &#123;​ Redis redisProperties = cacheProperties.getRedis();​ RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();​ Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = getJackson2JsonRedisSerializer();​ config = config.serializeKeysWith(SerializationPair.fromSerializer(new StringRedisSerializer()));​ config = config.serializeValuesWith(SerializationPair.fromSerializer(jackson2JsonRedisSerializer));​ config = handleRedisCacheConfiguration(redisProperties, config);​ return config;​ &#125;​ private Jackson2JsonRedisSerializer getJackson2JsonRedisSerializer() &#123;​ Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);​ ObjectMapper om = new ObjectMapper();​ om.setVisibility(PropertyAccessor.GETTER, JsonAutoDetect.Visibility.ANY);​ om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);​ om.setSerializationInclusion(Include.NON_NULL);​ om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);​ jackson2JsonRedisSerializer.setObjectMapper(om);​ return jackson2JsonRedisSerializer;​ &#125;​ private RedisCacheConfiguration handleRedisCacheConfiguration(Redis redisProperties,​ RedisCacheConfiguration config) &#123;​ if (Objects.isNull(redisProperties)) &#123;​ return config;​ &#125;​ if (redisProperties.getTimeToLive() != null) &#123;​ config = config.entryTtl(redisProperties.getTimeToLive());​ &#125;​ if (redisProperties.getKeyPrefix() != null) &#123;​ config = config.computePrefixWith(cacheName -&gt; cacheName + redisProperties.getKeyPrefix());​ &#125;​ if (!redisProperties.isCacheNullValues()) &#123;​ config = config.disableCachingNullValues();​ &#125;​ if (!redisProperties.isUseKeyPrefix()) &#123;​ config = config.disableKeyPrefix();​ &#125;​ return config;​ &#125;&#125;我们自定的缓存的配置，使用了现有的CacheProperties.Redis作为配置类。 123456789@Data@ConfigurationProperties(prefix = “damon.cache”)public class CustomCacheProperties &#123;​ private Map&lt;String, CacheProperties.Redis&gt; customCache;&#125; Redis的key配置，过期时间，是否允许缓存空值默认可以，key的前缀，是否允许使用key前缀 1234567891011121314public static class Redis &#123; private Duration timeToLive; private boolean cacheNullValues = true; private String keyPrefix; private boolean useKeyPrefix = true;&#125;再来看看配置项 spring.cache.redis就为当前redis-cache的默认配置 底下的damon.cache就为自定义配置(默认20秒)，如下配置了testA和 testB2个自定义key的过期时间(一个40秒，一个50秒) 123456789101112131415161718spring: redis: host: localhost port: 6379 cache:​ redis: time-to-live: 20sdamon: cache: custom-cache: testA: time-to-live: 40s testB: time-to-live: 50s redis-cache的key名调整 从上述我们可以看出使用后，缓存过期时间可以自定义配置了，但是key名中间有2个冒号。 RedisCacheRedisCacheConfigurationCacheKeyPrefixRedisCache中的createCacheKey方法是生成redis的key，从中可以看出是否使用prefix，使用的话通过prefixCacheKey方法生成，借用了redisCache配置项来生成。 1234567891011121314151617181920private final RedisCacheConfiguration cacheConfig;protected String createCacheKey(Object key) &#123; String convertedKey = convertKey(key); if (!cacheConfig.usePrefix()) &#123; return convertedKey; &#125; return prefixCacheKey(convertedKey);&#125;private String prefixCacheKey(String key) &#123; // allow contextual cache names by computing the key prefix on every call. return cacheConfig.getKeyPrefixFor(name) + key;&#125;在redisCache配置项中使用getKeyPrefixFor方法来生成完整的redis的key名，通过 keyPrefix.compute来生成。 参考 12345678910private final CacheKeyPrefix keyPrefix;public String getKeyPrefixFor(String cacheName) &#123; Assert.notNull(cacheName, “Cache name must not be null!”); return keyPrefix.compute(cacheName);&#125;这里就看到我们使用处，而且看到了默认实现有2个冒号的实现。 其实是在RedisCacheConfiguration中有个默认实现方法，里面用的就是CacheKeyPrefix的默认实现。我们只有覆盖此处即可。 123456789101112131415@FunctionalInterfacepublic interface CacheKeyPrefix &#123;//计算在redis中的缓存名String compute(String cacheName);//默认实现，中间用的就是：： static CacheKeyPrefix simple() &#123;return name -&gt; name + “::”; &#125;&#125; 总结参考上文，使用RedisCacheConfiguration的computePrefixWith(cacheName -&gt; cacheName + redisProperties.getKeyPrefix())实现key调整。 题外话我们再来聊聊spring-cache，实际上其实它就是把缓存的使用给抽象了，在对缓存的具体实现的过程中给抽出来。其实最重要的就是Cache和CacheManager2个接口，简单的实现如SimpleCacheManager。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之备忘录模式]]></title>
    <url>%2F2019%2F01%2F26%2Fdesign-pattern-memento%2F</url>
    <content type="text"><![CDATA[备忘录模式Without violating encapsulation, capture and externalize an object’s internal state allowing the object to be restored to this state later.在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。通过一个备忘录类专门存储对象状态。客户不与备忘录类耦合，与备忘录管理类耦合。 备忘录模式UML UML类图Caretaker类是指用于保存(createMemento())和还原(restore(memento))发起方内部状态的Originator类。发起方类实现（1）createMemento()，通过创建和返回存储发起方当前内部状态的memento对象（2）通过从传入的memento对象还原状态来还原(memento)。 UML时序图（1）保存发起人的内部状态：Caretaker对Originator调用createMemento()，创建memento对象，保存其当前内部状态(setState())，并将memento返回给Caretaker。 （2）恢复发起人的内部状态：Caretaker对Originator调用restore(memento)，并指定存储应恢复状态的memento对象。发起者从memento获取状态(getState())以设置其自己的状态。 备忘录模式角色结构(1) 备忘录（Memento）角色：备忘录角色存储“备忘发起角色”的内部状态。“备忘发起角色”根据需要决定备忘录角色存储“备忘发起角色”的哪些内部状态。为了防止“备忘发起角色”以外的其他对象访问备忘录。备忘录实际上有两个接口，“备忘录管理者角色”只能看到备忘录提供的窄接口——对于备忘录角色中存放的属性是不可见的。“备忘发起角色”则能够看到一个宽接口——能够得到自己放入备忘录角色中属性。 (2) 备忘发起（Originator）角色：“备忘发起角色”创建一个备忘录，用以记录当前时刻它的内部状态。在需要时使用备忘录恢复内部状态。 (3) 备忘录管理者（Caretaker）角色：负责保存好备忘录。不能对备忘录的内容进行操作或检查。 干货示例源码地址 CaretakerOriginatorMemento123456789101112131415161718public class Caretaker &#123;​ public static void main(String[] args) &#123;​ List&lt;Memento&gt; savedStates = new ArrayList();​ Originator originator = new Originator();​ originator.set(“State1”);​ originator.set(“State2”);​ savedStates.add(originator.saveToMemento());​ originator.set(“State3”);​ savedStates.add(originator.saveToMemento());​ originator.set(“State4”);​ originator.restoreFromMemento(savedStates.get(1));​ &#125;&#125;12345678910111213141516171819202122232425@Slf4jpublic class Originator &#123;​ private String state;​ //状态更改​ public void set(String state) &#123;​ this.state = state;​ log.info(“Originator: Setting state to &#123;&#125;”, state);​ &#125;​ //将状态保存到备忘录里​ public Memento saveToMemento() &#123;​ log.info(“Originator: Saving to Memento.”);​ return new Memento(this.state);​ &#125;​ //从备忘录里取出状态并回滚​ public void restoreFromMemento(Memento memento) &#123;​ this.state = memento.getState();​ log.info(“Originator: State after restoring from Memento: &#123;&#125;”, state);​ &#125;&#125;12345678910@Data@AllArgsConstructorpublic class Memento &#123;​ //状态维护​ private String state;&#125; 示例结果 从上述代码中看的出，随着状态变更，用List维护发起者的状态列表，从备忘录中取出状态以便回退状态。 java中的使用生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。Date对象通过自身内部的一个long值来实现备忘录模式。 java.util.Date java.io.Serializable 总结优点 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 使用场景1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。 注意事项1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。 参考备忘录模式|菜鸟教程 Memento pattern 细数JDK里的设计模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之观察者模式]]></title>
    <url>%2F2019%2F01%2F24%2Fdesign-pattern-observer%2F</url>
    <content type="text"><![CDATA[观察者模式Define a one-to-many dependency between objects where a state change in one object results in all its dependents being notified and updated automatically.直译过来就是，定义对象间的一对多依赖关系，当一个对象的状态变更会自动通知和更新所有依赖项。像发布/订阅模式，事件通知模式，数据源/监听模式等都是性质一样。 观察者模式UMLUML类和时序图类图：Subject类不会直接更新从属对象的状态。相反，Subject引用了用于更新状态的观察者接口（update()），这使得Subject独立于依赖对象的状态更新方式。Observer1和Observer2类通过将状态与Subject的状态同步来实现Observer接口。 时序图：Observer1和Observer2对象调用Subject1上的attach(this)来注册自己。假如Subject1的状态发生变更，Subject1本身调用notify()。notify()对已注册的Observer1和Observer2对象调用update()，后者从Subject1请求已更改的数据（getState()）以更新（同步）其状态。 UML类图 观察者模式角色 Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。 ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。 Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。 ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。 观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态以使其状态与目标状态同步，这种交互也称为发布-订阅(Publish-Subscribe)。观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 干货源码解析源码地址 博客订阅的功能，抽象主题中维护订阅关系，同时引入普通和vip观察者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//抽象主题@Datapublic abstract class Subject &#123; //主题订阅者们 private List&lt;Observer&gt; observerList = Lists.newArrayList(); //订阅 public void register(Observer observer) &#123; observerList.add(observer); &#125; //取消订阅 public void remove(Observer observer) &#123; observerList.remove(observer); &#125; //发布东西 public abstract void publish(String msg);&#125;//抽象观察者@Slf4j@Data@AllArgsConstructorpublic abstract class Observer &#123; //观察者名称 private String name; //更新状态，由主题调度 public void update(Object subject, Object args) &#123; log.info("&#123;&#125;获取到变更通知：&#123;&#125;", name, args); &#125;&#125;//博客主题@Slf4jpublic class Blog extends Subject &#123; @Override public void publish(String msg) &#123; log.info("发布msg:&#123;&#125;", msg); //通知订阅者 getObserverList().forEach(observer -&gt; observer.update(this, msg)); &#125;&#125;//普通用户观察者@Slf4jpublic class NormalObserver extends Observer &#123; public NormalObserver(String name) &#123; super(name); &#125; @Override public void update(Object subject, Object args) &#123; super.update(subject, args); log.info("&#123;&#125;获取到变更通知：普通用户可以不缓存", getName()); &#125;&#125;//vip用户观察者@Slf4jpublic class VipObserver extends Observer &#123; public VipObserver(String name) &#123; super(name); &#125; @Override public void update(Object subject, Object args) &#123; super.update(subject, args); log.info("&#123;&#125;获取到变更通知：vip可以缓存", getName()); &#125;&#125;@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Blog blog = new Blog(); VipObserver wang = new VipObserver("老王99"); VipObserver lee = new VipObserver("老李"); NormalObserver four = new NormalObserver("小四"); NormalObserver twoEgg = new NormalObserver("二蛋"); log.info("---------------------begin--------------------"); // 用户订阅博客，普通和vip用户 new Thread(() -&gt; &#123; blog.register(wang); sleep(2); blog.register(lee); sleep(2); blog.register(four); &#125;).start(); // 博客线程每隔2秒发布一次文章, 总共发布4次 new Thread(() -&gt; &#123; IntStream.rangeClosed(1, 4).forEach(i -&gt; &#123; blog.publish(String.format("新把戏第%s次", i)); sleep(2); &#125;); &#125;).start(); // 有用户退出订阅博客，也有二蛋加入订阅 new Thread(() -&gt; &#123; sleep(3); blog.remove(lee); sleep(2); blog.register(twoEgg); &#125;).start(); &#125; private static void sleep(int seconds) &#123; try &#123; TimeUnit.SECONDS.sleep(seconds); &#125; catch (InterruptedException e) &#123; log.error("error : ", e); &#125; &#125;&#125; jdk内置的Obverser和Observable 1234567891011121314151617181920212223242526272829@Slf4jpublic class ObserverApplication &#123; public static void main(String[] args) &#123; log.info("Enter Text: "); EventSource eventSource = new EventSource(); eventSource.addObserver((obj, arg) -&gt; &#123; log.info("Received response: &#123;&#125;", arg); &#125;); eventSource.addObserver((obj, arg) -&gt; &#123; log.info("Received response2: &#123;&#125;,,&#123;&#125;", arg, obj ); &#125;); new Thread(eventSource).start(); &#125;&#125;class EventSource extends Observable implements Runnable &#123; public void run() &#123; while (true) &#123; String response = new Scanner(System.in).next(); setChanged(); notifyObservers(response); &#125; &#125;&#125; Java中的使用它使得一个对象可以灵活的将消息发送给感兴趣的对象 java.util.EventListener javax.servlet.http.HttpSessionBindingListener javax.servlet.http.HttpSessionAttributeListener javax.faces.event.PhaseListener Listener从名字上看就明白是监听的意思了。 JDK中内置的Obverser和Observablejdk中内置的观察者模式。即是java.util.Observer(接口)和java.util.Observable(类)。 简单的说说这个。观察者接口(java.util.Observer)，主题(java.util.Observable)。实现观察者接口和继承主题。通过抽象主题的addObserver()注册观察者，deleteObserver()移除观察者。 首先通过调用主题类的setChange()告知状态变更，随后调用notifyObservers方法（可传可不传参数）去通知观察者，最后因为主题在notifyObservers时会主动调用观察者的update()方法，改方法有2个参数，第一个为主题对象，第二个为可变参数。 总结观察者模式是一种使用频率非常高的设计模式，JDK中就带有实现。无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。观察者模式广泛应用于各种编程语言的GUI事件处理的实现，在基于事件的XML解析技术（如SAX2）以及Web事件处理中也都使用了观察者模式。 观察者模式的优点(1) 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。(2) 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。(3) 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。(4) 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 观察者模式的缺点(1) 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。(2) 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。(3) 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 注意事项1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 参考Observer pattern 观察者模式|菜鸟教程 细数JDK里的设计模式 设计模式总结（Java）—— 观察者模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql我是怎么随机截取字符数组里的字符串并且一一对应]]></title>
    <url>%2F2019%2F01%2F17%2Fmysql_rand_func%2F</url>
    <content type="text"><![CDATA[场景：临近年底，各个App都会有个人年度账单，项目里为了图快，以及节省各个系统模块之间的接口联调。直接人工统计数据（😳😳😳😳😳😳😳😳😳😳😳😳😳😳），构造账单数据JSON。 话不多说，老夫拿起键盘就是干。 无独有偶，数据按部就班的由其他各个系统小组提供，但是有些数据是随机生成的一些描述性的文本，而该文本从固定的文本数组而来。前端展示效果又要将随机文本拆成几个部分来。 正常的sql拼接成json还方便。 12CONCAT('\"app\":&#123;\"time\":\"', DATE_FORMAT(time, "%Y-%m-%d %T"), '\",\"days\":', days, case when typeTime is null then '' else CONCAT(',\"typeTime\":\"', DATE_FORMAT(typeTime, "%Y-%m-%d %T"), '\"') end,'&#125;') 随机文本来了 学富五车：再美的气质，也掩盖不了你才华本质足智多谋：脑力使用积极分子，非你莫属仗义执言：你的见解，面面俱到，深入人心火眼金睛：独特的洞察力，总能获悉一切见多识广：最美的阅历，就是沿路的风景责任担当：先天下之忧而忧,后天下之乐而乐 从上面可以看的出，它们之间一一对应的。 唯独那些随机文本着实思考片刻。来，我们层层剖析它。 截取文本mysql中怎么从数组中取随机的文本，参考substring_index函数。分为两步走，第一步先去倒数开始往前数倒数几位，第二步再从新的数组中取第一位。 1substring_index(substring_index(array, '符合间隔', -n), '符合间隔', 1) 构造随机因子现在再看看这个随机因子怎么取，参考rand()函数。 因为取的是-1到-7之间的随机数。所以最终的效果就是如下。 1-floor(rand()*7+1) 取随机范围内的值可以参考这个公式 1FLOOR(start_num + RAND() * (end_num - start_num + 1)) 第一次截取，每次随机随机串截取方法有了，随机数也有了，开干。 12345select user_id, CONCAT('\"desc\": &#123;\"label\":\"', substring_index(substring_index('学富五车;足智多谋;仗义执言;火眼金睛;见多识广;责任担当;乐观积极',';',-FLOOR(rand()*7+1)),';',1),'\"',',\"description\": \"', substring_index(substring_index('再美的气质，也掩盖不了你才华本质;脑力使用积极分子，非你莫属;你的见解，面面俱到，深入人心;独特的洞察力，总能获悉一切;最美的阅历，就是沿路的风景;先天下之忧而忧,后天下之乐而乐;爱笑的你运气一定不会差',';',-FLOOR(rand()*7+1)),';',1),'\"&#125;') as report_content from data; 结果发现对不上啊，【责任担当】应该对应【先天下之忧而忧,后天下之乐而乐】，而结果出现部分对应到【再美的气质，也掩盖不了你才华本质】 第二次截取，先一次随机两次用这次考虑到上回我们是把随机因子放在每个字段sql里，所以每次都执行了2次，生成是随机因子就不一样了，截取的结果就对应不上，那，我们先在子查询里先把随机因子生成后，再在外层用这个随机因子这下应该不一样了把。 12345select temp.user_id, CONCAT('\"desc\": &#123;\"label\":\"', substring_index(substring_index('学富五车;足智多谋;仗义执言;火眼金睛;见多识广;责任担当;乐观积极',';',temp.desc_index),';',1),'\"',',\"description\": \"', substring_index(substring_index('再美的气质，也掩盖不了你才华本质;脑力使用积极分子，非你莫属;你的见解，面面俱到，深入人心;独特的洞察力，总能获悉一切;最美的阅历，就是沿路的风景;先天下之忧而忧,后天下之乐而乐;爱笑的你运气一定不会差',';',temp.desc_index),';',1),'\"&#125;') as report_content from (select user_id, -FLOOR(rand()*7+1) as desc_index from data) temp 吐血的图片在查找中，从开头看就看的出来，对应不上啦，前几个就前部对应【爱笑的你运气一定不会差】，爱笑的我，运气就是这么差。 改变下语句把随机因子打印出来 12345select temp.user_id, desc_index, CONCAT(desc_index, '\"desc\": &#123;\"label\":\"', substring_index(substring_index('学富五车;足智多谋;仗义执言;火眼金睛;见多识广;责任担当;乐观积极',';',temp.desc_index),';',1),'\"',',\"description\": \"', substring_index(substring_index('再美的气质，也掩盖不了你才华本质;脑力使用积极分子，非你莫属;你的见解，面面俱到，深入人心;独特的洞察力，总能获悉一切;最美的阅历，就是沿路的风景;先天下之忧而忧,后天下之乐而乐;爱笑的你运气一定不会差',';',temp.desc_index),';',1),'\"&#125;') as report_content from (select user_id, -FLOOR(rand()*7+1) as desc_index from data) temp WTF，随机因子，明明在子查询都生成了，为毛还是不一样。 来自官方大佬的截取本想在子查询中使用rand()把随机因子可以搞出来，哪成想，在外层的查询时rand()又重算了一遍。 一顿参考一顿找资料，偶然间发现了问题所在 Mysql尽然有这样的bug 2017年有个哥们提了这样的一个issue，就是上面的链接。 里面说了一些情况，在mysql5.6里，随机数是一样的，5.7里随机数不一样。如果子查询里不使用表，随机数也是一样。刚刚好mysql就是5.7，刚刚好中招了。 根据ISSUE作者和Roy Lyseng的建议，我用limit，没想到，尽然阔以啦，老泪纵横啊。 还是老外好，成功的解决方案，也会在issue里说明下的。 改造后的最终样子。 12345select temp.user_id, desc_index, CONCAT(desc_index, '\"desc\": &#123;\"label\":\"', substring_index(substring_index('学富五车;足智多谋;仗义执言;火眼金睛;见多识广;责任担当;乐观积极',';',temp.desc_index),';',1),'\"',',\"description\": \"', substring_index(substring_index('再美的气质，也掩盖不了你才华本质;脑力使用积极分子，非你莫属;你的见解，面面俱到，深入人心;独特的洞察力，总能获悉一切;最美的阅历，就是沿路的风景;先天下之忧而忧,后天下之乐而乐;爱笑的你运气一定不会差',';',temp.desc_index),';',1),'\"&#125;') as report_content from (select user_id, -FLOOR(rand()*7+1) as desc_index from data limit 100000) temp]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之中介者模式]]></title>
    <url>%2F2019%2F01%2F15%2Fdesign-pattern-mediator%2F</url>
    <content type="text"><![CDATA[中介者模式 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 通俗点来讲就是提供一个中介平台，说到平台，那其实很容易联系到我们很熟悉的房地产中介。我们可以直接通过这个平台得到我们想要的信息，不用对象自身与其他对象交互。 买房子租房子就不需要去找房东，只需要在中介那里获取相应的房产信息。如下图那样，两方只需要找中介即可。 再来看一张对比图。 有没有感觉没有使用之前，对象间互相依赖互相调用，错综复杂，盘根错节，当加入中介者后，对象间的关系一目了然，清晰明了。由中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。 中介者模式UML图UML类图和时序图 collague1和collague2类不直接相互依赖，它们是用起控制和协调交互作用的公共中介接口（mediate（）方法），这使它们有独立交互的执行方式。mediate1类实现collague1和collague2之间的依赖。 中介者模式角色 抽象中介者(Mediator): 定义了同事对象到中介者对象之间的接口。 具体中介者(ConcreteMediator): 实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。 抽象同事类(Colleague): 定义了中介者对象的接口，它只知道中介者而不知道其他的同事对象。 具体同事类(ConcreteColleague) : 每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。 示例代码源码地址 抽象中介者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Slf4jpublic abstract class Mediator &#123; /** * 房东map */ protected Map&lt;People, Message&gt; landlordMap = Maps.newHashMap(); /** * 租户列表 */ protected List&lt;People&gt; renterList = Lists.newArrayList(); /** * 注册房东信息 * * @param landlord 房东 * @param message 房屋信息 */ public void registerLandlord(People landlord, Message message) &#123; landlordMap.put(landlord, message); log.info("中介信息：房东|&#123;&#125;|加入到中介平台，房屋信息：&#123;&#125;", landlord.getName(), message); &#125; /** * 变更房东信息 * * @param landlord 房东 * @param message 房屋信息 */ protected void modifyLandlordInfo(People landlord, Message message) &#123; landlordMap.put(landlord, message); log.info("中介信息：房东|&#123;&#125;|修改他在中介平台的房屋信息，现房屋信息：&#123;&#125;", landlord.getName(), message); &#125; /** * 注册租户信息 * * @param renter 租户 */ public void registerRenter(People renter) &#123; renterList.add(renter); log.info("中介信息：租户|&#123;&#125;|来中介平台租房", renter.getName()); &#125; /** * 声明抽象方法 由具体中介者子类实现 消息的中转和协调 */ public abstract void operation(People people, Message message);&#125; 抽象同事类 12345678910111213141516171819@Data@AllArgsConstructor@NoArgsConstructorpublic abstract class People &#123; private Mediator mediator; private String name; /** * 向中介发送消息 */ protected abstract void sendMessage(Message message); /** * 从中介获取消息 */ protected abstract void getMessage(Message message);&#125; 具体同事类 房东和租户 1234567891011121314151617@Slf4jpublic class Landlord extends People &#123; public Landlord(Mediator mediator, String name) &#123; super(mediator, name); &#125; @Override protected void sendMessage(Message message) &#123; getMediator().operation(this, message); &#125; @Override protected void getMessage(Message message) &#123; log.info("房东|&#123;&#125;|从中介获取到租户的信息：&#123;&#125;", getName(), message); &#125;&#125; 1234567891011121314151617@Slf4jpublic class Renter extends People &#123; public Renter(Mediator mediator, String name) &#123; super(mediator, name); &#125; @Override protected void sendMessage(Message message) &#123; getMediator().operation(this, message); &#125; @Override protected void getMessage(Message message) &#123; log.info("租户|&#123;&#125;|从中介获取到房东的信息：&#123;&#125;", getName(), message); &#125;&#125; 具体中介者 123456789101112131415161718public class RealEstateAgent extends Mediator &#123; @Override public void operation(People people, Message message) &#123; if (people instanceof Renter) &#123; // 将租户的租房条件信息发送给房东们 landlordMap.keySet().forEach(landlord -&gt; landlord.getMessage(message)); // 租户收到中介那里房东的房屋信息 landlordMap.values().forEach(messages -&gt; people.getMessage(messages)); &#125; else if (people instanceof Landlord) &#123; // 将房东的房屋信息发送给租户们 renterList.forEach(renter -&gt; renter.getMessage(message)); // 变更中介里的房东房屋信息 modifyLandlordInfo(people, message); &#125; &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Mediator mediator = new RealEstateAgent(); People laoWang = new Landlord(mediator, "老王"); People laoLee = new Landlord(mediator, "老李"); People laoBai = new Landlord(mediator, "老白"); People xiaoSan = new Renter(mediator, "小3"); People xiaoWang = new Renter(mediator, "小王"); mediator.registerLandlord(laoWang, Message.builder().msg("我这有2500的房子，市中心").build()); mediator.registerLandlord(laoBai, Message.builder().msg("我这有2000的房子，地铁旁").build()); mediator.registerLandlord(laoLee, Message.builder().msg("我这有2000的房子，落地阳台，大空间，采光好，地铁旁").build()); mediator.registerRenter(xiaoSan); log.info("小3开始找房子"); xiaoSan.sendMessage(Message.builder().msg("想找个月租2000块的房子，靠近地铁").build()); log.info("没过多久---------老白升级了房屋信息"); laoBai.sendMessage(Message.builder().msg("我这有2000的房子，地铁旁，我又加了空调和热水器").build()); mediator.registerRenter(xiaoWang); log.info("小王开始找房子"); xiaoWang.sendMessage(Message.builder().msg("想找个月租2500块的房子，靠近地铁").build()); log.info("没过多久---------老李也升级了房屋信息"); laoBai.sendMessage(Message.builder().msg("我这有2000的房子，落地阳台，大空间，采光好，地铁旁，我也加了空调和热水器").build()); &#125;&#125; 最终出效果的如下 现在我来分析下里面各个角色的作用： 首先先分析两个抽象类。抽象同事类，含有名称和中介者的引用，有2个方法从中介拿信息和发信息给中介。抽象中介者，其中含有房东的map信息，key为房东数据，value为房东的房屋信息，用来房东注册和房东房屋信息变更；租户的列表信息，供租户注册，同时还有个协调方法，用于协调房东和租户。 具体抽象类（房地产中介），实现了抽象中介者的协调方法，当租户发送消息时，将租户的租房条件信息发送给所有房东们同时该租户收到中介那里所有房东的房屋信息；当房东发送消息时，将房东的房屋信息发送给所有租户们同时变更中介里的改房东房屋信息。 具体同事实现类（房东和租户），实现了抽象同事类的读取消息方法和发送消息方法（该房屋就是依靠中介者的协调方法来实现）。 JDK中的应用通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。 java.util.Timer java.util.concurrent.Executor#execute() java.util.concurrent.ExecutorService#submit() java.lang.reflect.Method#invoke() 总结优点使用中介者模式可以把对个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合。中介者模式可以将原先多对多的同事对象关系变成中介者对象一对多同事对象的关系，这样会让对象之间的关系更容易理解和实现。同事对象之间的交互都被封装到中介者对象里面集中管理，集中了控制交互。当交互发生改变时，着重修改的是中介者对象。当需要扩展中介者对象时，其他同事对象不需要做修改。 缺点如果同事对象多了，交互也复杂了。中介者会庞大，变得复杂难以维护。 参考中介者模式|菜鸟教程 Mediator pattern 细数JDK里的设计模式 JAVA设计模式之 中介者模式【Mediator Pattern】]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>中介者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴开源分布式事务解决方案 FESCAR【转】]]></title>
    <url>%2F2019%2F01%2F13%2Ffescar%2F</url>
    <content type="text"><![CDATA[偶然间看到阿里开源的分布式事务中间件，期待有投入到生产阶段的栗子。从蓝图上看出目前有支持dubbo的解决方案，后续0.5.x版本会推出支持spring cloud的方案。 下面看官方正文，喜欢的可以去官方Github上瞧瞧看看。 Fescar 是 阿里巴巴 开源的 分布式事务中间件，以 高效 并且对业务 0 侵入 的方式，解决 微服务 场景下面临的分布式事务问题。 1. 什么是微服务化带来的分布式事务问题？首先，设想一个传统的单体应用（Monolithic App），通过 3 个 Module，在同一个数据源上更新数据来完成一项业务。 很自然的，整个业务过程的数据一致性由本地事务来保证。 随着业务需求和架构的变化，单体应用被拆分为微服务：原来的 3 个 Module 被拆分为 3 个独立的服务，分别使用独立的数据源（Pattern: Database per service）。业务过程将由 3 个服务的调用来完成。 此时，每一个服务内部的数据一致性仍有本地事务来保证。而整个业务层面的全局数据一致性要如何保障呢？这就是微服务架构下面临的，典型的分布式事务需求：我们需要一个分布式事务的解决方案保障业务全局的数据一致性。 2. Fescar 的发展历程阿里是国内最早一批进行应用分布式（微服务化）改造的企业，所以很早就遇到微服务架构下的分布式事务问题。 2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。 2016 年，TXC 经过产品化改造，以 GTS（Global Transaction Service）的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品，在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。 2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast &amp; EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。 TXC/GTS/Fescar 一脉相承，为解决微服务架构下的分布式事务问题交出了一份与众不同的答卷。 2.1 设计初衷高速增长的互联网时代，快速试错 的能力对业务来说是至关重要的： 一方面，不应该因为技术架构上的微服务化和分布式事务支持的引入，给业务层面带来额外的研发负担。 另一方面，引入分布式事务支持的业务应该基本保持在同一量级上的性能表现，不能因为事务机制显著拖慢业务。 基于这两点，我们设计之初的最重要的考量就在于： 对业务无侵入： 这里的 侵入 是指，因为分布式事务这个技术问题的制约，要求应用在业务层面进行设计和改造。这种设计和改造往往会给应用带来很高的研发和维护成本。我们希望把分布式事务问题在 中间件 这个层次解决掉，不要求应用在业务层面做额外的工作。 高性能： 引入分布式事务的保障，必然会有额外的开销，引起性能的下降。我们希望把分布式事务引入的性能损耗降到非常低的水平，让应用不因为分布式事务的引入导致业务的可用性受影响。 2.2 既有的解决方案为什么不满足？既有的分布式事务解决方案按照对业务侵入性分为两类，即：对业务无侵入的和对业务有侵入的。 业务无侵入的方案既有的主流分布式事务解决方案中，对业务无侵入的只有基于 XA 的方案，但应用 XA 方案存在 3 个方面的问题： 要求数据库提供对 XA 的支持。如果遇到不支持 XA（或支持得不好，比如 MySQL 5.7 以前的版本）的数据库，则不能使用。 受协议本身的约束，事务资源的锁定周期长。长周期的资源锁定从业务层面来看，往往是不必要的，而因为事务资源的管理器是数据库本身，应用层无法插手。这样形成的局面就是，基于 XA 的应用往往性能会比较差，而且很难优化。 已经落地的基于 XA 的分布式解决方案，都依托于重量级的应用服务器（Tuxedo/WebLogic/WebSphere 等)，这是不适用于微服务架构的。 侵入业务的方案实际上，最初分布式事务只有 XA 这个唯一方案。XA 是完备的，但在实践过程中，由于种种原因（包含但不限于上面提到的 3 点）往往不得不放弃，转而从业务层面着手来解决分布式事务问题。比如： 基于可靠消息的最终一致性方案 TCC Saga 都属于这一类。这些方案的具体机制在这里不做展开，网上这方面的论述文章非常多。总之，这些方案都要求在应用的业务层面把分布式事务技术约束考虑到设计中，通常每一个服务都需要设计实现正向和反向的幂等接口。这样的设计约束，往往会导致很高的研发和维护成本。 2.3 理想的方案应该是什么样子？不可否认，侵入业务的分布式事务方案都经过大量实践验证，能有效解决问题，在各行种业的业务应用系统中起着重要作用。但回到原点来思考，这些方案的采用实际上都是 迫于无奈。设想，如果基于 XA 的方案能够不那么 重，并且能保证业务的性能需求，相信不会有人愿意把分布式事务问题拿到业务层面来解决。 一个理想的分布式事务解决方案应该：像使用 本地事务 一样简单，业务逻辑只关注业务层面的需求，不需要考虑事务机制上的约束。 3. 原理和设计我们要设计一个对业务无侵入的方案，所以从业务无侵入的 XA 方案来思考： 是否可以在 XA 的基础上演进，解决掉 XA 方案面临的问题呢？ 3.1 如何定义一个分布式事务？首先，很自然的，我们可以把一个分布式事务理解成一个包含了若干 分支事务 的 全局事务。全局事务 的职责是协调其下管辖的 分支事务 达成一致，要么一起成功提交，要么一起失败回滚。此外，通常 分支事务 本身就是一个满足 ACID 的 本地事务。这是我们对分布式事务结构的基本认识，与 XA 是一致的。 其次，与 XA 的模型类似，我们定义 3 个组件来协议分布式事务的处理过程。 Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。 Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。 Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。 一个典型的分布式事务过程： TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。 XID 在微服务调用链路的上下文中传播。 RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖。 TM 向 TC 发起针对 XID 的全局提交或回滚决议。 TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。 至此，Fescar 的协议机制总体上看与 XA 是一致的。 3.2 与 XA 的差别在什么地方？架构层次 XA 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身（通过提供支持 XA 的驱动程序来供应用使用）。 而 Fescar 的 RM 是以二方包的形式作为中间件层部署在应用程序这一侧的，不依赖与数据库本身对协议的支持，当然也不需要数据库支持 XA 协议。这点对于微服务化的架构来说是非常重要的：应用层不需要为本地事务和分布式事务两类不同场景来适配两套不同的数据库驱动。 这个设计，剥离了分布式事务方案对数据库在 协议支持 上的要求。 两阶段提交先来看一下 XA 的 2PC 过程。 无论 Phase2 的决议是 commit 还是 rollback，事务性资源的锁都要保持到 Phase2 完成才释放。 设想一个正常运行的业务，大概率是 90% 以上的事务最终应该是成功提交的，我们是否可以在 Phase1 就将本地事务提交呢？这样 90% 以上的情况下，可以省去 Phase2 持锁的时间，整体提高效率。 这个设计，在绝大多数场景减少了事务持锁时间，从而提高了事务的并发度。 当然，你肯定会问：Phase1 即提交的情况下，Phase2 如何回滚呢？ 3.3 分支事务如何提交和回滚？首先，应用需要使用 Fescar 的 JDBC 数据源代理，也就是 Fescar 的 RM。 Phase1： Fescar 的 JDBC 数据源代理通过对业务 SQL 的解析，把业务数据在更新前后的数据镜像组织成回滚日志，利用 本地事务 的 ACID 特性，将业务数据的更新和回滚日志的写入在同一个 本地事务 中提交。 这样，可以保证：任何提交的业务数据的更新一定有相应的回滚日志存在。 基于这样的机制，分支的本地事务便可以在全局事务的 Phase1 提交，马上释放本地事务锁定的资源。 Phase2： 如果决议是全局提交，此时分支事务此时已经完成提交，不需要同步协调处理（只需要异步清理回滚日志），Phase2 可以非常快速地完成。 如果决议是全局回滚，RM 收到协调器发来的回滚请求，通过 XID 和 Branch ID 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。 3.4 事务传播机制XID 是一个全局事务的唯一标识，事务传播机制要做的就是把 XID 在服务调用链路中传递下去，并绑定到服务的事务上下文中，这样，服务链路中的数据库更新操作，就都会向该 XID 代表的全局事务注册分支，纳入同一个全局事务的管辖。 基于这个机制，Fescar 是可以支持任何微服务 RPC 框架的。只要在特定框架中找到可以透明传播 XID 的机制即可，比如，Dubbo 的 Filter + RpcContext。 对应到 Java EE 规范和 Spring 定义的事务传播属性，Fescar 的支持如下： PROPAGATION_REQUIRED： 默认支持 PROPAGATION_SUPPORTS： 默认支持 PROPAGATION_MANDATORY：应用通过 API 来实现 PROPAGATION_REQUIRES_NEW：应用通过 API 来实现 PROPAGATION_NOT_SUPPORTED：应用通过 API 来实现 PROPAGATION_NEVER：应用通过 API 来实现 PROPAGATION_REQUIRED_NESTED：不支持 3.5 隔离性全局事务的隔离性是建立在分支事务的本地隔离级别基础之上的。 在数据库本地隔离级别 读已提交 或以上的前提下，Fescar 设计了由事务协调器维护的 全局写排他锁，来保证事务间的 写隔离，将全局事务默认定义在 读未提交 的隔离级别上。 我们对隔离级别的共识是：绝大部分应用在 读已提交 的隔离级别下工作是没有问题的。而实际上，这当中又有绝大多数的应用场景，实际上工作在 读未提交 的隔离级别下同样没有问题。 在极端场景下，应用如果需要达到全局的 读已提交，Fescar 也提供了相应的机制来达到目的。默认，Fescar 是工作在 读无提交 的隔离级别下，保证绝大多数场景的高效性。 事务的 ACID 属性在 Fescar 中的体现是一个比较复杂的话题，我们会有专门的文章来深入分析，这里不做进一步展开。 4. 适用场景分析前文所述的 Fescar 的核心原理中有一个 重要前提：分支事务中涉及的资源，必须 是支持 ACID 事务的 关系型数据库。分支的提交和回滚机制，都依赖于本地事务的保障。所以，如果应用使用的数据库是不支持事务的，或根本不是关系型数据库，就不适用。 另外，目前 Fescar 的实现还存在一些局限，比如：事务隔离级别最高支持到 读已提交 的水平，SQL 的解析还不能涵盖全部的语法等。 为了覆盖 Fescar 原生机制暂时不能支持应用场景，我们定义了另外一种工作模式。 上面介绍的 Fescar 原生工作模式称为 AT（Automatic Transaction）模式，这种模式是对业务无侵入的。与之相应的另外一种工作模式称为 MT（Manual Transaction）模式，这种模式下，分支事务需要应用自己来定义业务本身及提交和回滚的逻辑。 4.1 分支的基本行为模式作为全局事务一部分的分支事务，除本身的业务逻辑外，都包含 4 个与协调器交互的行为： 分支注册： 在分支事务的数据操作进行之前，需要向协调器注册，把即将进行的分支事务数据操作，纳入一个已经开启的全局事务的管理中去，在分支注册成功后，才可以进行数据操作。 状态上报： 在分支事务的数据操作完成后，需要向事务协调器上报其执行结果。 分支提交：响应协调器发出的分支事务提交的请求，完成分支提交。 分支回滚：响应协调器发出的分支事务回滚的请求，完成分支回滚。 4.2 AT 模式分支的行为模式业务逻辑不需要关注事务机制，分支与全局事务的交互过程自动进行。 4.3 MT 模式分支的行为模式业务逻辑需要被分解为 Prepare/Commit/Rollback 3 部分，形成一个 MT 分支，加入全局事务。 MT 模式一方面是 AT 模式的补充。另外，更重要的价值在于，通过 MT 模式可以把众多非事务性资源纳入全局事务的管理中。 4.4 混合模式因为 AT 和 MT 模式的分支从根本上行为模式是一致的，所以可以完全兼容，即，一个全局事务中，可以同时存在 AT 和 MT 的分支。这样就可以达到全面覆盖业务场景的目的：AT 模式可以支持的，使用 AT 模式；AT 模式暂时支持不了的，用 MT 模式来替代。另外，自然的，MT 模式管理的非事务性资源也可以和支持事务的关系型数据库资源一起，纳入同一个分布式事务的管理中。 4.5 应用场景的远景回到我们设计的初衷：一个理想的分布式事务解决方案是不应该侵入业务的。MT 模式是在 AT 模式暂时不能完全覆盖所有场景的情况下，一个比较自然的补充方案。我们希望通过 AT 模式的不断演进增强，逐步扩大所支持的场景，MT 模式逐步收敛。未来，我们会纳入对 XA 的原生支持，用 XA 这种无侵入的方式来覆盖 AT 模式无法触达的场景。 5. 扩展点5.1 微服务框架的支持事务上下文在微服务间的传播需要根据微服务框架本身的机制，订制最优的，对应用层透明的解决方案。有兴趣在这方面共建的开发者可以参考内置的对 Dubbo 的支持方案，来实现对其他微服务框架的支持。 5.2 所支持的数据库类型因为 AT 涉及 SQL 的解析，所以在不同类型的数据库上工作，会有一些特定的适配。有兴趣在这方面共建的开发者可以参考内置的对 MySQL 的支持方案，来实现对其他数据库的支持。 5.3 配置和服务注册发现支持接入不同的配置和服务注册发现解决方案。比如：Nacos、Eureka、ZooKeeper 等。 5.4 MT 模式的场景拓展MT 模式的一个重要作用就是，可以把非关系型数据库的资源，通过 MT 模式分支的包装，纳入到全局事务的管辖中来。比如，Redis、HBase、RocketMQ 的事务消息等。有兴趣在这方面共建的开发者可以在这里贡献一系列相关生态的适配方案。 5.5 事务协调器的分布式高可用方案针对不同场景，支持不同的方式作为事务协调器 Server 端的高可用方案。比如，针对事务状态的持久化，可以是基于文件的实现方案，也可以是基于数据库的实现方案；集群间的状态同步，可以是基于 RPC 通信的方案，也可以是基于高可用 KV 存储的方案。 6. Roadmap蓝图 绿色 部分是已经开源发布出来的，黄色 部分是将在后续版本中由阿里发布出来的，蓝色 部分是我们和社区共建生态部分： 对不同数据库的支持，开发者可以参考 MySQL 的实现。 对不同微服务框架的支持，开发者可以参考 Dubbo 的实现。 对 MQ、NoSQL 的支持，开发者可以参考 TCC 的实现。 配置和服务注册发现：开发者通过少量的工作可以接入任何可以提供这类服务的框架。 当然，非 蓝色 的部分也非常欢迎社区参与进来，贡献更优的解决方案。 另外，XA 作为分布式事务的标准，是一个完备的分布式事务解决方案不可或缺的，远景的规划中，我们一定需要把 XA 的支持加入进来。 初步的版本规划v0.1.0 微服务框架支持: Dubbo 数据库支持: MySQL 基于 Spring AOP 的 Annotation 事务协调器: 单机版本 v0.5.x 微服务框架支持: Spring Cloud MT 模式 支持 TCC 模式事务的适配 动态配置和服务发现 事务协调器: 高可用集群版本 v0.8.x Metrics 控制台: 监控/部署/升级/扩缩容 v1.0.0 General Availability: 生产环境适用 v1.5.x 数据库支持: Oracle/PostgreSQL/OceanBase 不依赖 Spring AOP 的 Annotation 热点数据的优化处理机制 RocketMQ 事务消息纳入全局事务管理 NoSQL 纳入全局事务管理的适配机制 支持 HBase 支持 Redis v2.0.0 支持 XA 当然，项目迭代演进的过程，我们最重视的是社区的声音，路线图会和社区充分交流及时进行调整。 7. 相关链接 FESCAR on GitHub GTS on Aliyun]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>事务</tag>
        <tag>XA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之解释器模式]]></title>
    <url>%2F2019%2F01%2F10%2Fdesign-pattern-interpreter%2F</url>
    <content type="text"><![CDATA[解释器模式 是类的行为模式，给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。 意图 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决 对于一些固定文法构建一个解释句子的解释器。 何时使用 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决 构件语法树，定义终结符与非终结符。 关键代码 构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。 解释器模式相关UML图类图 可以看出右侧的协作图(object collaboration diagram)展现出运行时的解释器模式。Client向右侧抽象语法树发送解释请求，请求被转发并向下到树结构的所有对象。 解释器模式的主要角色 抽象解释器(AbstractExpression/Expression)：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。 终结符表达式(TerminalExpression)：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 非终结符表达式(NonterminalExpression)：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。 环境角色(Context)：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。 干货代码跳转到源码地址 简单的一个解释器计算加减乘除算法，环境上下文没有用好，其实计算规则更多的是人为设定的了。 本次的抽象接收器用的是抽象类，用接口代替也可以。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//抽象解释器public abstract class AbstractExpression &#123; public abstract int interpreter(Context context);&#125;//非终结表达式：加法@Data@AllArgsConstructorpublic class Add extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; return left.interpreter(context) + right.interpreter(context); &#125;&#125;//非终结表达式：减法@Data@AllArgsConstructorpublic class Subtract extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; return left.interpreter(context) - right.interpreter(context); &#125;&#125;//非终结表达式：乘法@Data@AllArgsConstructorpublic class Multiply extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; return left.interpreter(context) * right.interpreter(context); &#125;&#125;//非终结表达式：除法@Data@AllArgsConstructorpublic class Division extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; int right = this.right.interpreter(context); if (right != 0) &#123; return left.interpreter(context) / right; &#125; return -1; &#125;&#125;//终结表达式：变量@Data@AllArgsConstructorpublic class Variable extends AbstractExpression &#123; private final String key; @Override public int interpreter(Context context) &#123; return context.getValue(key); &#125;&#125;//环境上下文@Getterpublic class Context &#123; private final Map&lt;String, Integer&gt; valueMap = Maps.newHashMap(); public void addValue(final String key, final int value) &#123; valueMap.put(key, Integer.valueOf(value)); &#125; public int getValue(final String key) &#123; return valueMap.get(key).intValue(); &#125;&#125;//public class Application &#123; public static void main(String[] args) &#123; Context context = new Context(); context.addValue("a", 6); context.addValue("b", 9); context.addValue("c", 1); Variable a = new Variable("a"); Variable b = new Variable("b"); Variable c = new Variable("c"); AbstractExpression multiplyValue = new Multiply(a, b); AbstractExpression subtractValue = new Subtract(a, b); AbstractExpression addValue = new Add(subtractValue, c); AbstractExpression divisionValue = new Division(multiplyValue, addValue); log.info("&#123;&#125;", context.getValueMap()); log.info("(a*b)/(a-b+c) = &#123;&#125;", divisionValue.interpreter(context)); &#125;&#125; 结果如下： Java中的应用 java中的表达式引擎parsiiJEvalJEPLiteexprJaninoMathEval Java表达式引擎fel/groovy/expression4j/java脚本引擎的性能对比 JDK中的应用这个模式通常定义了一个语言的语法，然后解析相应语法的语句。 java.util.Pattern java.text.Normalizer java.text.Format 参考解释器模式|菜鸟教程 Interpreter pattern 细数JDK里的设计模式 23种设计模式（14）：解释器模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之访问者模式]]></title>
    <url>%2F2019%2F01%2F07%2Fdesign-pattern-visitor%2F</url>
    <content type="text"><![CDATA[访问者模式 Represent an operation to be performed on the elements of an object structure. Visitor lets a new operation be defined without changing the classes of the elements on which it operates. 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。 意图 主要将数据结构与数据操作分离。 主要解决 稳定的数据结构和易变的操作耦合问题。 何时使用 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 访问者模式的主要角色 Visitor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。 ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。 Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。 ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。 ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 访问者模式相关UML图UML类图和时序图 在类图中可以看出，ElementA实现了接口Element的accept(visitor)方法，而通过visitor.visitElementA(this)，相同visitor1类通过实现visitElementA(ElementA a)方法与ElementA关联。相同的ElementB亦是如此原理。 右上角的时序图，Client对象有一组Element的数据结构，通过循环对每个元素Element调用accept(visitor)方法，例如先是ElementA调用accept(visitor)，实际上就是调用visitor1的visitElementA(A)，同样情况对ElementB。 更加清晰的类图如下 实例干货跳转到对应的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//抽象元素public interface Element &#123; void accept(ElementVisitor visitor);&#125;//具体元素-车轮@Data@AllArgsConstructorpublic class Wheel implements Element &#123; private String name; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-车身public class Body implements Element &#123; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-引擎public class Engine implements Element &#123; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-整车public class Car implements Element &#123; public void accept(final ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//抽象访问者public interface ElementVisitor &#123; void visit(Body body); void visit(Engine engine); void visit(Wheel wheel); void visit(Car car);&#125;//具体的一个访问者，纯打印@Slf4jpublic class DoElementVisitor implements ElementVisitor &#123; @Override public void visit(Body body) &#123; log.info("Moving my body"); &#125; @Override public void visit(Engine engine) &#123; log.info("Starting my engine"); &#125; @Override public void visit(Wheel wheel) &#123; log.info("Kicking my " + wheel.getName() + " wheel"); &#125; @Override public void visit(Car car) &#123; log.info("Starting my car"); &#125;&#125;//单独还定义对象结构，其实完全就可以使用列表就可以@Datapublic class ElementStructure &#123; private List&lt;Element&gt; list = Lists.newArrayList(); public void addElement(Element element)&#123; list.add(element); &#125; public void accept(ElementVisitor visitor) &#123; for (Element elem : list) &#123; elem.accept(visitor); &#125; &#125;&#125; 上述就是针对访问者模式做的一个对于汽车零件的一个打印效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ClientWithVisitor &#123; public static void main(String[] args) &#123; ElementStructure structure = new ElementStructure(); structure.addElement(new Wheel("front left")); structure.addElement(new Wheel("front right")); structure.addElement(new Wheel("back left")); structure.addElement(new Wheel("back right")); structure.addElement(new Body()); structure.addElement(new Engine()); structure.addElement(new Car()); structure.accept(new DoElementVisitor()); &#125;&#125;@Slf4jpublic class ClientWithoutVisitor &#123; public static void main(String[] args) &#123; ElementStructure structure = new ElementStructure(); structure.addElement(new Wheel("front left")); structure.addElement(new Wheel("front right")); structure.addElement(new Wheel("back left")); structure.addElement(new Wheel("back right")); structure.addElement(new Body()); structure.addElement(new Engine()); structure.addElement(new Car()); structure.getList().forEach(e -&gt; &#123; if (e instanceof Body) &#123; log.info("Moving my body"); &#125; else if (e instanceof Engine) &#123; log.info("Starting my engine"); &#125; else if (e instanceof Car) &#123; log.info("Starting my car"); &#125; else if (e instanceof Wheel) &#123; log.info("Kicking my " + ((Wheel)e).getName() + " wheel"); &#125; &#125;); &#125;&#125; 打印结果都是一样的 总结分析在上面的例子中分别用了访问者模式和非访问者模式两种方法。 1、使用VIsitor的好处一目了然，当需要修改某些元素的业务逻辑时，只需要修改Visitor类中相对应的操作函数即可。例如假设要修改Wheel的逻辑，只需要修改Visitor的visit(Wheel wheel)方法即可。 2、假设我们又需要新增一个汽车元素天窗的话，只需要在visitor中添加新的接口以处理新元素，而别的元素可以保持不动。 违背开闭原则。 3、当我们需要添加新的业务操作，只需要添加新的具体访问者，其他的依旧可以保持不变。符合开闭原则。 同样，有好处也就有缺陷，因为逻辑在visitor里面，所有visitor和Element高度耦合，同样针对visit方法返回类型，需要设计的优雅，如若不然，后期一旦修改返回类型，影响的范围就广，所有访问者接口和实现都波及到。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问，这一点跟迪米特法则和依赖倒置原则相违背。 总的而言，访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。 JDK中含有的访问者模式提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。 javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor 参考访问者模式|菜鸟教程 Visitor pattern JAVA设计模式（23）：行为型-访问者模式（Visitor）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计模式原则]]></title>
    <url>%2F2019%2F01%2F05%2Fprinciples-of-software-design-patterns%2F</url>
    <content type="text"><![CDATA[软件设计模式原则在我们面向对象的设计过程中，我们的code既要可读性高方便维护，同时还需要另外一个可复用性。这次我们来学习软件设计模式中涉及到的一些原则————&gt;面向对象设计 SOLID 这就是吐槽： 但是我们往往接手的项目，都是苦不堪言，一把鼻涕一把泪，看前人留下的杰作，那是相当痛苦，千万匹MMP奔腾，填坑，还技术债。 入正题，在有些说七大原则，有些说六大原则，有些说五大原则，但是最重要的就是SOLID了。 国内的博文大部分都说七大和六大原则，Google下solid，看老外的文章和wiki都是五大原则。 我们先看SOLID，是罗伯特·C·马丁搞出来的首字母缩写记忆，这个Bob大叔。 Single Responsibility Principle：单一职责原则，解释：一个类只负责一个功能领域中的相应职责 Open Closed Principle：开闭原则，解释：软件实体应对扩展开放，而对修改关闭 Liskov Substitution Principle：里氏替换原则，解释：所有引用基类对象的地方能够透明地使用其子类的对象 Interface Segregation Principle：接口隔离原则，解释：使用多个专门的接口，而不使用单一的总接口 Dependence Inversion Principle：依赖倒置原则，解释：抽象不应该依赖于细节，细节应该依赖于抽象 剩下的两大原则 Composite Reuse Principle 合成复用原则，解释：尽量使用对象组合，而不是继承来达到复用的目的 Law of Demeter 迪米特法则，解释：一个软件实体应当尽可能少地与其他实体发生相互作用 单一职责原则 a class should have only a single responsibility (i.e. only changes to one part of the software’s specification should be able to affect the specification of the class). 顾名思义，就是一个类只负责一个职责。不能有多个导致类变更的原因。 让类的职责单一，只需要负责自己部分，复杂度就会降低，代码维护起来也更加容易。原则不仅仅适用于类，对于接口和方法也适用，即一个接口/方法，只负责一件事，这样的话，接口就会变得简单，方法中的代码也会更少，易读，便于维护。事实上，由于一些其他的因素影响，类的单一职责在项目中是很难保证的。通常，接口和方法的单一职责更容易实现。 好处： 代码的粒度降低了，类的复杂度降低了。 可读性提高了，每个类的职责都很明确，可读性自然更好。 可维护性提高了，可读性提高了，一旦出现 bug ，自然更容易找到他问题所在。 改动代码所消耗的资源降低了，更改的风险也降低了。 高内聚、低耦合 假设有一类C，含有logging、order、pay3个方法，实则就这个类就不是单一指责了，按要求后我们保留单一指责order方法。后期需求来了，我们要对order方法进行修改，产生了order1和order2，尽量在方法级别保留了单一指责，或者这个时候修改为类C1和C2，都有order方法。这两种方法，我们往往选择前者较多，但是有些2者都不选择，直接就在类C中order方法进行修改，支持多种需求，在这一步就违法单一指责。需求有可能在未来导致order方法扩散到n个。记住，在指责扩散到无法控制时，一定要重构。 开闭原则 software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. 软件实体如类、模块、方法等对于扩展开放的，但是对于修改封闭的。 我们试想一下，产品来需求了，对我们原有的代码要进行升级或者改变的时候，可能我们在修改旧的业务代码时，往往也会新增新的bug，这个时候，有可能因为功能复杂情况下要对整个功能进行重构。这个时候，就应该想到开闭原则，通过扩展实现改变而不是修改原有的东西。 有没有感觉，对扩展开放，对修改关闭。说起来很简单，感觉像啥也没说一样，具体起来该如何做。 Open–closed principle中一文有描述，通过继承抽象类和实现接口。 其实，这也正是我们面向对象中的框架设计—–抽象，用抽象构建框架，用实现扩展细节。我们队框架进行关闭，通过实现细节进行开放。而我们的业务常常就是这些细节，通过细节的实现，我们就能完成扩展。但是前提是我们的框架要足够抽象化，具有针对需求的满足性，要有足够的预埋性，这其实也是需要一定的经验。 里氏替换原则 objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. 程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。简单点，就是我用基类代替子类的话，程序还是一样的，是对的。 Liskov substitution principle有讲明里氏替换原则的来路。Barbara Liskov女士提出来的。 PDF中有相关的介绍 是这么定义的： 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 通俗点理解： 例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在使用里氏代换原则时需要注意如下几个问题： (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 12345678910111213class A&#123; public int func1(int a, int b)&#123; return a-b; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); System.out.println("100-50="+a.func1(100, 50)); System.out.println("100-80="+a.func1(100, 80)); &#125;&#125; 运行结果： 100-50=50 100-80=20 123456789101112131415161718class B extends A&#123; public int func1(int a, int b)&#123; return a+b; &#125; public int func2(int a, int b)&#123; return func1(a,b)+100; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; B b = new B(); System.out.println("100-50="+b.func1(100, 50)); System.out.println("100-80="+b.func1(100, 80)); System.out.println("100+20+100="+b.func2(100, 20)); &#125;&#125; 类B完成后，运行结果： 100-50=150 100-80=180 100+20+100=220 通过这个举例可以看出子类改变了父类原有的功能，子类无意或者有意重写了父类的方法。导致本来的减法变成了加法。 接口隔离原则 many client-specific interfaces are better than one general-purpose interface. 多个特定客户端接口要好于一个宽泛用途的接口。 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。将一个庞大的接口变更为多个专用的接口所采用的就是接口隔离原则。 例如：接口I有5个方法M1,M2,M3,M4,M5，假设现在有3个实现类C1实现5分方法，实现类C2只实现前面3个方法M1,M2,M3其他2个则是空实现，实现类C3只实现M4,M5其他3个则是空实现。这个时候就体现出接口庞大了。此时应将接口I拆分成接口I1有方法M1,M2,M3，接口I2有方法M4,M5。而实现类C1实现接口I1和I2，实现类C2实现接口I1，实现类C3实现接口I2。 接口隔离原则跟单一职责原则很相似。其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 依赖倒置原则 one should “depend upon abstractions, [not] concretions. 依赖于抽象而不是一个实例。其实想想依赖注入是该原则的一种实现方式。 The principle states: High-level modules should not depend on low-level modules. Both should depend on abstractions). Abstractions should not depend on details. Details should depend on abstractions. 翻译过来是：高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节。细节应该依赖抽象。 在Java语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。接口或抽象类不依赖于实现类。实现类依赖于接口或抽象类。 简而言之，尽可能的使用接口或者抽象类，即所谓的面向接口编程。 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 这张图，其实就很好的表达了依赖倒置原则，ObjectB应该依赖InterfaceA去申明ObjectA而非直接去依赖ObjectA，而ObjectA也应该依赖InterfaceA，这就是高层模块不应该依赖底层模块，两者都应该依赖其抽象和细节应该依赖抽象。 我们来看看如下的示例，刚开始，学生只是简单的完成学校里的白天课堂作业。 12345678910111213141516public class SchoolWork &#123; public void work() &#123; System.out.println("学生每天在学校就完成课堂作业了"); &#125;&#125;public class Student &#123; public void work(SchoolWork schoolWork) &#123; schoolWork.work(); &#125;&#125;//客户端调用Student student = new Student();SchoolWork work = new SchoolWork();student.work(work); 我们发现，学生每天都在课堂上就完成了作业，但是随着时间慢慢的过去，学生们，课堂作业变多了，老师开始布置家庭作业了。那么Student类中再写一个写家庭作业的方法嘛，万一老师又给学生布置其他作业又写一种方法吗，肯定不是的啦。 这个时候就需要把作业抽象起来了，用接口或者抽象类都可以。 12345678910111213141516171819202122232425262728public interface Work &#123; public void work();&#125;public class SchoolWork implements Work &#123; public void work() &#123; System.out.println("学生每天在学校就完成课堂作业了"); &#125;&#125;public class HomeWork implements Work &#123; public void work() &#123; System.out.println("学生每天在家就完成家庭作业了"); &#125;&#125;public class Student &#123; public void work(Work work) &#123; work.work(); &#125;&#125;//客户端调用Student student = new Student();Work work = new SchoolWork();student.work(work);work = new HomeWork();student.work(work); 这就是面向接口编程。Work work = new SchoolWork();和work = new HomeWork();就是变量的声明类型尽量是抽象类或者接口。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 迪米特法则From Wikipedia, the free encyclopedia Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.Each unit should only talk to its friends; don’t talk to strangers.Only talk to your immediate friends. 每个单位对其他单位的了解应该是有限，除了跟自己相对密切的单位。的不要和陌生人说话啊，只与直接的朋友通信。 看完之后，是不是云里雾里，不知道说什么鸟语花香。其实就是，一个对象应该对其他对象保持最少的了解。啊，你还是不知道它说了个啥。通俗的讲就是一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类，向外公开的方法应该尽可能的少(尽可能的不用用public修饰方法)。对于上面的朋友的定义来讲，两个对象之间的耦合关系称之为朋友，通常有依赖、关联、聚合和组成等。而直接朋友则通常表现为关联、聚合和组成关系，即两个对象之间联系更为紧密，通常以成员变量、方法的参数和返回值的形式出现。同时了陌生的类最好不要作为局部变量的形式出现在类的内部。 朋友了也是有这样几种定义的 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象，如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。 来看个示例，关计算机的业务。 主要是针对只暴露应该暴露的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//计算机类public class Computer&#123; public void saveCurrentTask()&#123; //do something &#125; public void closeService()&#123; //do something &#125; public void closeScreen()&#123; //do something &#125; public void closePower()&#123; //do something &#125; public void close()&#123; saveCurrentTask(); closeService(); closeScreen(); closePower(); &#125;&#125;//人public class Person&#123; private Computer c; ... public void clickCloseButton()&#123; //现在你要开始关闭计算机了，正常来说你只需要调用close（）方法即可， //但是你发现Computer所有的方法都是公开的，该怎么关闭呢？于是你写下了以下关闭的流程： c.saveCurrentTask(); c.closePower(); c.close(); //亦或是以下的操作 c.closePower(); //还可能是以下的操作 c.close(); c.closePower(); &#125;&#125; 从被依赖者的角度，只应该暴露应该暴露的方法。那么这里的c对象应该哪些方法应该是被暴露的呢？很显然，对于Person来说，只需要关注计算机的关闭操作，而不关心计算机会如何处理这个关闭操作，因此只需要暴露close（）方法即可。 1234567891011121314151617181920212223242526272829303132333435//计算机类public class Computer&#123; private void saveCurrentTask()&#123; //do something &#125; private void closeService()&#123; //do something &#125; private void closeScreen()&#123; //do something &#125; private void closePower()&#123; //do something &#125; public void close()&#123; saveCurrentTask(); closeService(); closeScreen(); closePower(); &#125;&#125;//人public class Person&#123; private Computer c; ... public void clickCloseButton()&#123; c.close(); &#125;&#125; 再来看一个示例，只依赖应该依赖的对象 123456789101112131415161718192021222324252627282930313233343536373839public class A &#123; public D do(B b) &#123; C c = b.getC().; c.doSomething(); D d = c.getResult() return d; &#125;&#125;@Datapublic class B &#123; private C c;&#125;@Datapublic class C &#123; public void doSomething() &#123; //..... &#125; public D getResult() &#123; //..... return new D(); &#125;&#125;@Datapublic class D &#123; //.......&#125;public class Client &#123; public void main(String[] args) &#123; A a = new A(); B b = new B(); System.out.println(a.do(b)); &#125;&#125; 从上述例子中，可以看出，在A类的do方法中，类C其实相对于类A来说就是陌生人，高耦合在A类中。假设日后，我们对C类的doSomething和getResult方法改动时，就会影响到类A。 至于如何修改，想看看看官们有什么建议或者实现，欢迎留言。 总的来说，在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。高内聚，低耦合。 合成复用原则也称为合成/聚合复用原则，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 其原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。 如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 聚合（Aggregation）表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象但B对象不是A对象的一部分。如上图中的大雁属于雁群的，一个雁群是有很多大雁。聚合关系用空心的菱形+实线来表示。 合成（Composition）则是一种强的’拥有’关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。例如上图大雁人是有头、翅膀等合成的，大雁和头、翅膀的生命周期是一样的，大家一起玩完。合成关系用实心的菱形+实线来表示。 通常类的复用分为继承复用和合成复用 两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 总结单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 参考SOLID Design Principles Explained The SOLID Principles in Real Life S.O.L.I.D: The First 5 Principles of Object Oriented Design SOLID 设计模式六大原则——SOLID 软件设计模式六大原则 浅谈 SOLID 原则的具体使用 白话设计——浅谈迪米特法则 合成复用原则——面向对象设计原则]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之迭代器模式]]></title>
    <url>%2F2019%2F01%2F02%2Fdesign-pattern-iterator%2F</url>
    <content type="text"><![CDATA[迭代器模式 Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 提供一种不公示其底层细节(结构)的情况下能顺序访问聚合对象元素的方法。其实在java体系中，jdk已经引入了迭代器接口以及对于的容器接口等。就拿迭代器中的角色，在java中找出其对应的类。 具体角色 (1)迭代器角色(Iterator)：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法next()，判断是否遍历结束的方法hasNext()），移出当前对象的方法remove(), (2)具体迭代器角色(Concrete Iterator)：实现迭代器接口中定义的方法，完成集合的迭代。 (3)容器角色(Aggregate): 一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等 (4)具体容器角色(ConcreteAggregate)：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。 单独举出ArrayList的角色， 迭代器角色对应java中的java.lang.Iterator，这个迭代器是java容器公用的。 容器角色对应java.lang.Iterable，其还有Iterator iterator()方法获取迭代器。 具体迭代器角色对应java.lang.ArrayList.Itr，实现了对应的hasNext、next、remove方法。 具体容器角色那就是java.lang.ArrayList了，实现iterator方法返回Itr具体迭代器，用游标形式实现。 再看看UML类 项目实例源码在Github 项目中很简单的实现了一个容器和迭代器。大致参考了ArrayList实现，但是是简洁版本，去除很多无关以及性能上的东西，只保留最基本的迭代器元素。 12345678910111213141516@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Aggregate&lt;Integer&gt; aggregate = new ConcreteAggregate&lt;&gt;(); aggregate.add(1); aggregate.add(2); aggregate.add(3); aggregate.add(4); Iterator&lt;Integer&gt; iterator = aggregate.iterator(); while (iterator.hasNext()) &#123; log.info("循环数据&#123;&#125;", iterator.next()); &#125; &#125;&#125; 执行结果如下 简单的迭代器定义 1234567public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next();&#125; 简单容器定义 1234567public interface Aggregate&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); void add(T t);&#125; 具体容器和具体的迭代器定义 123456789101112131415161718192021222324252627282930313233343536373839404142public class ConcreteAggregate&lt;E&gt; implements Aggregate&lt;E&gt; &#123; private Object[] elements; private int size = 0; public ConcreteAggregate() &#123; elements = new Object[16]; &#125; public int getSize() &#123; return size; &#125; public void add(E e) &#123; elements[size++] = e; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ConcreteIterator&lt;E&gt;(); &#125; private class ConcreteIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; int cursor; @Override public boolean hasNext() &#123; return cursor != size; &#125; @Override public E next() &#123; if (cursor &gt;= size) &#123; return null; &#125; return (E) elements[cursor++]; &#125; &#125;&#125; 具体容器中用数组来作为容器来存储元素，而且最简单的容器，固定了大小，并没有实现扩容的算法等等，只是一个简单的样例，但是大部分上，都是直接使用java带有的迭代器。 优点 简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。 可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。 封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。 缺点由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。 总结迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。 参考wiki的迭代器模式 迭代器模式|菜鸟教程 Java设计模式系列之迭代器模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之命令模式]]></title>
    <url>%2F2019%2F01%2F02%2Fdesign-pattern-command%2F</url>
    <content type="text"><![CDATA[命令模式 wiki上的描述 Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests, and the queuing or logging of requests. It also allows for the support of undoable operations. 翻译意思，把请求封装成一个对象，从而允许我们可以对客户端的不同请求进行参数化，以及对请求进行排队或记录。还允许支持撤销操作。看起来好像很复杂，很难理解。 通俗简单理解，它就是将请求封装成一个对象，在这里就是这个对象就是命令，而这个命令就是将请求方和执行方分离隔开。从而每一个命令其实就是操作，而这样的流程就是请求方发出请求要求执行某操作，接收方收到请求后并执行对应的操作。这样下来，请求方和接收方就解耦了，使得请求方完全不知道接受的操作方法，从也不会知道接收方是何时接受到请求的，又是何时执行操作的，又是怎么执行操作的。 具体的角色 Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。 ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。 Invoker（请求方）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。 Receiver（接收方）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。 Client（客户端）：创建具体命令的对象并且设置命令对象的接受者。 再来看看UML图 从上方的时序图中可以看出运行的顺序，Invoker执行execute方法，调用Command1对象，Command1执行action1方法调用Receiver1对象。 干货代码源码在我的GitHub地址 普通的命令模式现在结合下上回说到的状态模式一起来实现这个风扇的左转和右转功能，这次把他用命令模式来代替之前风扇的转动，把它当做命令来。 客户端简单的定义请求方和接收方以及对于的左转命令和右转命令，设置命令后对应的执行命令。 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.setCommand(leftCommand); invoker.execute(); invoker.execute(); &#125;&#125; 请求方 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125;&#125; 抽象命令 1234public interface Command &#123; void execute();&#125; 开关左转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125;&#125; 开关右转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 通过命令模式把左转和右转封装成命令，以及之前的状态模式变更风扇的状态。本次就是通过状态模式和命令模式实现了一个风扇开关左右转的功能。 宏命令或者叫做组合命令设计一组命令，简单的处理事情，打印一句话，封装成一组命令。这次我们用了Java8来写，可以使用lambda。 12345678910111213141516171819202122232425262728@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); log.info("初始化ABC3个命令"); Command aCommand = () -&gt; log.info("A处理这个请求"); invoker.addCommand(aCommand); invoker.addCommand(() -&gt; log.info("B处理这个请求")); invoker.addCommand(() -&gt; log.info("C处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令D"); invoker.addCommand(() -&gt; log.info("D处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令E"); invoker.addCommand(() -&gt; log.info("E处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("移除命令A"); invoker.removeCommand(aCommand); invoker.execute(); &#125;&#125; 打印语句。 抽象命令 12345@FunctionalInterfacepublic interface Command &#123; void execute();&#125; 请求方 1234567891011121314151617181920212223@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private List&lt;Command&gt; commandList = Lists.newArrayList(); public void addCommand(Command command) &#123; commandList.add(command); &#125; public void removeCommand(Command command) &#123; commandList.remove(command); &#125; public void execute() &#123; if(CollectionUtils.isEmpty(commandList)) &#123; return; &#125; commandList.stream().forEach(command -&gt; command.execute()); &#125;&#125; 撤销操作在普通的命令模式的基础上，增加了撤销操作，在这里的撤销操作，其实即为左转时的右转，右转时的左转。 123456789101112131415161718192021@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.undo(); invoker.undo(); invoker.setCommand(leftCommand); invoker.execute(); invoker.undo(); &#125;&#125; 抽象命令增加了撤销操作 123456public interface Command &#123; void execute(); void undo();&#125; 具体左转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125; @Override public void undo() &#123; receiver.right(); &#125;&#125; 右转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125; @Override public void undo() &#123; receiver.left(); &#125;&#125; 请求方 12345678910111213141516@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125; public void undo() &#123; command.undo(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 命令模式总结优点 (1) 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 (2) 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 (3) 可以比较容易地设计一个命令队列或宏命令（组合命令）。 (4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。 适用场景 (1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 (2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 (3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 (4) 系统需要将一组操作组合在一起形成宏命令。 (5)线程池有一个addTash方法，将任务添加到待完成的队列中，队列中的元素就是命令对象，通常的就是一个公共接口，像我们常用的java.lang.Runnable接口。 (6)java8之后，最好在Command接口中@FunctionalInterface修饰，这样具体的命令就可以使用lambda表达式啦。 Java中的使用将操作封装到对象内，以便存储，传递和返回。 java.lang.Runnable javax.swing.Action 文章参考java设计模式之命令模式 细数JDK里的设计模式 wiki的命令模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之状态模式]]></title>
    <url>%2F2018%2F12%2F24%2Fdesign-pattern-state%2F</url>
    <content type="text"><![CDATA[状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。通俗点就是一个对象在内部状态发生改变时改变它的行为。 介绍意图 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用 代码中包含大量与对象状态有关的条件语句。 如何解决 将各种具体的状态类抽象出来。 关键代码 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 UML图 主要角色 1）Context(环境类)：环境类拥有各种不同状态的对象，作为外部使用的接口，负责调用状态类接口。 2）State(抽象状态)：抽象状态既可以为抽象类，也可以直接定义成接口。主要用于定义状态抽象方法，具体实现由子类负责。 3）ConcreteState(具体状态类):具体状态类为抽象状态的实现者，不同的状态类对应这不同的状态，其内部实现也不相同。环境类中使用不同状态的对象时，能实现不同的处理逻辑 应用实例 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景 行为随状态改变而改变的场景。 条件、分支语句的代替者。 状态模式和策略模式的对比现在我们知道，状态模式和策略模式的结构是相似的，但它们的意图不同。让我们重温一下它们的主要不同之处： 策略模式封装了一组相关算法，它允许Client在运行时使用可互换的行为；状态模式帮助一个类在不同的状态显示不同的行为。 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而通过从Context中分离出策略或算法，我们可以重用它们。 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。 策略实现可以作为参数传递给使用它的对象，例如Collections.sort()，它的参数包含一个Comparator策略。另一方面，状态是Context对象自己的一部分，随着时间的推移，Context对象从一个状态转移到另一个状态。 虽然它们都符合OCP原则，策略模式也符合SRP原则（单一职责原则），因为每个策略都封装自己的算法，且不依赖其他策略。一个策略的改变，并不会导致其他策略的变化。 另一个理论上的不同：策略模式定义了对象“怎么做”的部分。例如，排序对象怎么对数据排序。状态模式定义了对象“是什么”和“什么时候做”的部分。例如，对象处于什么状态，什么时候处在某个特定的状态。 状态模式中很好的定义了状态转移的次序；而策略模式并无此需要：Client可以自由的选择任何策略。 一些常见的策略模式的例子是封装算法，例如排序算法，加密算法或者压缩算法。如果你看到你的代码需要使用不同类型的相关算法，那么考虑使用策略模式吧。而识别何时使用状态模式是很简单的：如果你需要管理状态和状态转移，但不想使用大量嵌套的条件语句，那么就是它了。 最后但最重要的一个不同之处是，策略的改变由Client完成；而状态的改变，由Context或状态自己。 项目实例跳转到我的源码地址 simple1包中主要是对风扇的开关状态进行转换，其实我们是把状态放在状态类中进行按照固定的逻辑转换，但是这种模式其实他不符合开闭原则，为什么了，因为一旦我们发生新增、修改或者删除状态的时候，就需要修改状态类中的状态转换。 123456789101112public class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new CloseLevelState()); context.right(); context.right(); context.right(); context.left(); context.right(); context.right(); &#125;&#125; 抽象状态 12345678910111213141516171819202122public interface LevelState &#123; /** * 左转 * * @param context */ void left(Context context); /** * 右转 * * @param context */ void right(Context context); /** * 当前档位 * @return */ String info();&#125; 具体档位状态，我只列了2个，其他的类似 12345678910111213141516171819202122@Slf4jpublic class OneLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new CloseLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new TwoLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "1档"; &#125;&#125; 1234567891011121314151617181920212223@Slf4jpublic class CloseLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new ForeLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new OneLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "0档"; &#125;&#125; 真正的开关也就是上下文 123456789101112131415161718@Data@AllArgsConstructorpublic class Context &#123; private LevelState levelState; public void left() &#123; levelState.left(this); &#125; public void right() &#123; levelState.right(this); &#125; public String info() &#123; return levelState.info(); &#125;&#125; 参考Java中，状态模式和策略模式的区别 状态模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之责任链模式]]></title>
    <url>%2F2018%2F12%2F21%2Fdesign-pattern-chain%2F</url>
    <content type="text"><![CDATA[责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 简介意图 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用 在处理消息的时候以过滤很多道。 如何解决 拦截的类都实现统一接口。 关键代码 Handler 里面聚合它自己，在 handleRequest 里判断是否合适，如果没达到条件则向下传递。 纯责任链与不纯责任链 纯：纯责任链中的节点只有两种行为，一处理责任，二将责任传递到下一个节点。不允许出现某一个节点处理部分或全部责任后又将责任向下传递的情况。 不纯：允许某个请求被一个节点处理部分责任后再向下传递，或者处理完后其后续节点可以继续处理该责任，而且一个责任可以最终不被任何节点所处理。 主要角色 Handler（抽象处理者）： 定义一个处理请求的接口，提供对后续处理者的引用 ConcreteHandler（具体处理者）： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发 应用实例 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 Github项目描述跳转到我的责任链设计模式源码 1.出行方式travel包里主要对出行方式的责任链模式。跟进用户身上的钱，在优先级如飞机-&gt;火车-&gt;大巴的顺序下选择对应的出行模式。 123456789101112131415public class Application &#123; public static void main(String[] args) &#123; Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); planeHandler.setNext(trainHandler); trainHandler.setNext(busHandler); planeHandler.handleRequest("老王", 40d); planeHandler.handleRequest("张三", 140d); planeHandler.handleRequest("李四", 240d); planeHandler.handleRequest("吴老五", 340d); &#125;&#125; 抽象处理 12345678910@Datapublic abstract class Handler &#123; /** * 下一个链节点 */ protected Handler next; public abstract void handleRequest(String name, Double wallet);&#125; 具体的处理者（飞机、火车、大巴） 123456789101112131415161718@Slf4jpublic class PlaneHandler extends Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class TrainHandler extends Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class BusHandler extends Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 2.出行方式2，参考Filter链的写法travel2包是对travel包的重新写法。 1234567891011121314151617public class Application &#123; public static void main(String[] args) &#123; HandlerChain chain = new HandlerChain(); Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); chain.addHandler(planeHandler); chain.addHandler(trainHandler); chain.addHandler(busHandler); chain.handle("老王", 40d); chain.handle("张三", 140d); chain.handle("李四", 240d); chain.handle("吴老五", 340d); &#125;&#125; 抽象处理者 1234public interface Handler &#123; void handleRequest(String name, Double wallet, HandlerChain chain);&#125; 具体处理者（飞机、火车、大巴） 123456789101112131415@Slf4jpublic class PlaneHandler implements Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class TrainHandler implements Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class BusHandler implements Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 责任链管理者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Slf4jpublic class HandlerChain &#123; private List&lt;Handler&gt; handlerList = new ArrayList&lt;&gt;(); /** * 维护当前链上位置 */ private int pos; /** * 链的长度 */ private int handlerLength; public void addHandler(Handler handler) &#123; handlerList.add(handler); handlerLength = handlerList.size(); &#125; public void handle(String name, double wallet) &#123; if (CollectionUtils.isEmpty(handlerList)) &#123; log.error("有钱，但没提供服务，&#123;&#125;也估计就只能步行了。", name); return; &#125; if (pos &gt;= handlerLength) &#123; log.error("身上钱不够，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; Handler handler = handlerList.get(pos++); if (Objects.isNull(handler)) &#123; log.error("假服务，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; handler.handleRequest(name, wallet, this); &#125; /** * 链重新使用 */ public void reuse() &#123; pos = 0; &#125;&#125; 学习Web项目的Filter待补充… 补充补充遗留的Filter过滤器中的责任链处理。 本次主要是对Tomcat中的Filter处理简单的梳理，如有不正确的地方，还望指出来，大家互勉，共进。 老项目大家可以在web.xml中配置filter，现使用Springboot后，也有两种配置filter方式，通过创建FilterRegistrationBean的方式和通过注解@WebFilter+@ServletComponentScan的方式。 三个主要的角色 FIlter，不多介绍了。 FilterChain servlet容器提供的开发调用链的过滤请求的资源。通过调用下一个filter实现过滤，在整体链上。 FilterConfig filter的配置器，在servlet容器在Filter初始化的时候传递信息。 具体的filter，主要说说Spring中的两个抽象Filter，GenericFilterBean和OncePerRequestFilter。 前者主要是做init和destroy的操作，重点还是init方法，destroy只是空实现而已。 后者主要是做真正的doFilter操作，也是我们在Spring中创建Filter通常继承的。 而ApplicationFilterChain就算Tomcat中的FilterChain实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 /** * The int which is used to maintain the current position * in the filter chain. */ private int pos = 0; /** * The int which gives the current number of filters in the chain. */ private int n = 0;@Overridepublic void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //安全相关的，暂不关注 if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; try &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123; @Override public Void run() throws ServletException, IOException &#123; internalDoFilter(req,res); return null; &#125; &#125; ); &#125; catch( PrivilegedActionException pe) &#123; Exception e = pe.getException(); if (e instanceof ServletException) throw (ServletException) e; else if (e instanceof IOException) throw (IOException) e; else if (e instanceof RuntimeException) throw (RuntimeException) e; else throw new ServletException(e.getMessage(), e); &#125; &#125; else &#123; //真正的doFilter internalDoFilter(request,response); &#125;&#125;private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //pos 调用链中当前连接点所在的位置 //n 调用链总节点长度 // Call the next filter if there is one if (pos &lt; n) &#123; //对节点进行自增 pos++ ApplicationFilterConfig filterConfig = filters[pos++]; try &#123; //当前节点小于总长度后，从filter配置类中取出filter Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() &amp;&amp; "false".equalsIgnoreCase( filterConfig.getFilterDef().getAsyncSupported())) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res, this&#125;; SecurityUtil.doAsPrivilege ("doFilter", filter, classType, args, principal); &#125; else &#123; //真正的filter filter.doFilter(request, response, this); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.filter"), e); &#125; return; &#125; // We fell off the end of the chain -- call the servlet instance //到了调用链结尾处，就真正调用servlet实例的servlet.service(request, response); try &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // Use potentially wrapped request from this point if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res&#125;; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args, principal); &#125; else &#123; servlet.service(request, response); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.servlet"), e); &#125; finally &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(null); lastServicedResponse.set(null); &#125; &#125;&#125;/*** Prepare for reuse of the filters and wrapper executed by this chain.* 重复使用filter调用链，pos重设为0*/void reuse() &#123; pos = 0;&#125; 重点从ApplicationFilterChain中挑出几个重要的方法拿出来分析下Filter的调用链，其实还有几处没有具体讲到，ApplicationFilterChain是合适创建的，Filter是怎么加入到ApplicationFilterChain中的。这涉及到Tomcat是怎样加载Content的，下次分析Tomcat的时候，再来具体分析，它是如何运作的，如何加载web.xml。 参考维基的责任链模式 责任链模式|菜鸟教程 Filter、FilterConfig、FilterChain|菜鸟教程 南乡清水的实际项目运用之Responsibility-Chain模式 一起学设计模式 - 责任链模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之策略模式]]></title>
    <url>%2F2018%2F12%2F20%2Fdesign-pattern-strategy%2F</url>
    <content type="text"><![CDATA[策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。简单理解就是一组算法，可以互换，再简单点策略就是封装算法。 意图 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用 一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决 将这些算法封装成一个一个的类，任意地替换。 主要角色 上下文Context，拥有一个Strategy的引用 抽象策略Strategy，往往是一个接口(占大部分情况)或者抽象类，通常提供各种具体策略的接口 具体策略，这就是重点了，封装了各种具体的算法 UML 应用实例 诸葛亮的锦囊妙计，每一个锦囊就是一个策略； 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略； JAVA AWT 中的 LayoutManager； 优点 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 项目描述跳转到我的策略模式GitHub 1.操作行为simple1包，主要对操作行为包装了加减乘除方法。 1234567891011121314151617@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new AddStrategy()); log.info("10 + 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new SubstractStrategy()); log.info("10 - 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new MultiplyStrategy()); log.info("10 * 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new DivideStrategy()); log.info("10 / 5 = &#123;&#125;", context.executeStrategy(10, 5)); &#125;&#125; 执行结果 2.出现方式simple2包描述，主要对出行方式的包装，包装了3种出行方式， 执行类 12345678910111213public class TravelApplication &#123; public static void main(String[] args) &#123; Context context = new Context(new BusStrategy()); context.executeStrategy("老王"); context.setStrategy(new BicycleStrategy()); context.executeStrategy("老张"); context.setStrategy(new WalkStrategy()); context.executeStrategy("老李"); &#125;&#125; 执行结果 策略上下文 12345678910111213141516171819@Datapublic class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 出行 * * @return */ public void executeStrategy(String name) &#123; strategy.travel(name); &#125;&#125; 抽象策略 123456789public interface Strategy &#123; /** * 出现方法 * * @return */ void travel(String name);&#125; 参考策略模式|菜鸟教程 维基里的策略模式 南乡清水的实际项目运用之Strategy模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式汇总]]></title>
    <url>%2F2018%2F12%2F19%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[设计模式23种设计模式大纲… 软件设计模式原则 构建模式 Builder （建造者模式） Abstract Factory （抽象工厂模式） Factory Method （工厂方法） Prototype （原型模式） Singleton （单例模式） 结构模式 Adapter （适配器模式） Bridge （桥接模式） Composite （组合模式） Decorator （装饰模式） Facade （外观模式） Flyweight （享元模式） Proxy （代理模式） 行为模式 Chain of Responsibility（责任链模式） Command （命令模式） Interpreter （解释器模式） Iterator（迭代器模式） Mediator（中介者模式） Memento（备忘录模式） Observer（观察者模式） State（状态模式） Strategy (策略模式) Template Method （模板方法） Visitor（访问者模式）]]></content>
      <categories>
        <category>设计模式</category>
        <category>汇总</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试评论]]></title>
    <url>%2F2018%2F12%2F18%2Ftest%2F</url>
    <content type="text"><![CDATA[测试评论]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
