<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[折腾Java设计模式之访问者模式]]></title>
    <url>%2F2019%2F01%2F07%2Fdesign-pattern-visitor%2F</url>
    <content type="text"><![CDATA[访问者模式 Represent an operation to be performed on the elements of an object structure. Visitor lets a new operation be defined without changing the classes of the elements on which it operates. 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。 意图 主要将数据结构与数据操作分离。 主要解决 稳定的数据结构和易变的操作耦合问题。 何时使用 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 访问者模式的主要角色 Visitor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。 ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。 Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。 ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。 ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 访问者模式相关UML图UML类图和时序图 在类图中可以看出，ElementA实现了接口Element的accept(visitor)方法，而通过visitor.visitElementA(this)，相同visitor1类通过实现visitElementA(ElementA a)方法与ElementA关联。相同的ElementB亦是如此原理。 右上角的时序图，Client对象有一组Element的数据结构，通过循环对每个元素Element调用accept(visitor)方法，例如先是ElementA调用accept(visitor)，实际上就是调用visitor1的visitElementA(A)，同样情况对ElementB。 更加清晰的类图如下 实例干货跳转到对应的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//抽象元素public interface Element &#123; void accept(ElementVisitor visitor);&#125;//具体元素-车轮@Data@AllArgsConstructorpublic class Wheel implements Element &#123; private String name; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-车身public class Body implements Element &#123; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-引擎public class Engine implements Element &#123; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-整车public class Car implements Element &#123; public void accept(final ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//抽象访问者public interface ElementVisitor &#123; void visit(Body body); void visit(Engine engine); void visit(Wheel wheel); void visit(Car car);&#125;//具体的一个访问者，纯打印@Slf4jpublic class DoElementVisitor implements ElementVisitor &#123; @Override public void visit(Body body) &#123; log.info("Moving my body"); &#125; @Override public void visit(Engine engine) &#123; log.info("Starting my engine"); &#125; @Override public void visit(Wheel wheel) &#123; log.info("Kicking my " + wheel.getName() + " wheel"); &#125; @Override public void visit(Car car) &#123; log.info("Starting my car"); &#125;&#125;//单独还定义对象结构，其实完全就可以使用列表就可以@Datapublic class ElementStructure &#123; private List&lt;Element&gt; list = Lists.newArrayList(); public void addElement(Element element)&#123; list.add(element); &#125; public void accept(ElementVisitor visitor) &#123; for (Element elem : list) &#123; elem.accept(visitor); &#125; &#125;&#125; 上述就是针对访问者模式做的一个对于汽车零件的一个打印效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ClientWithVisitor &#123; public static void main(String[] args) &#123; ElementStructure structure = new ElementStructure(); structure.addElement(new Wheel("front left")); structure.addElement(new Wheel("front right")); structure.addElement(new Wheel("back left")); structure.addElement(new Wheel("back right")); structure.addElement(new Body()); structure.addElement(new Engine()); structure.addElement(new Car()); structure.accept(new DoElementVisitor()); &#125;&#125;@Slf4jpublic class ClientWithoutVisitor &#123; public static void main(String[] args) &#123; ElementStructure structure = new ElementStructure(); structure.addElement(new Wheel("front left")); structure.addElement(new Wheel("front right")); structure.addElement(new Wheel("back left")); structure.addElement(new Wheel("back right")); structure.addElement(new Body()); structure.addElement(new Engine()); structure.addElement(new Car()); structure.getList().forEach(e -&gt; &#123; if (e instanceof Body) &#123; log.info("Moving my body"); &#125; else if (e instanceof Engine) &#123; log.info("Starting my engine"); &#125; else if (e instanceof Car) &#123; log.info("Starting my car"); &#125; else if (e instanceof Wheel) &#123; log.info("Kicking my " + ((Wheel)e).getName() + " wheel"); &#125; &#125;); &#125;&#125; 打印结果都是一样的 总结分析在上面的例子中分别用了访问者模式和非访问者模式两种方法。 1、使用VIsitor的好处一目了然，当需要修改某些元素的业务逻辑时，只需要修改Visitor类中相对应的操作函数即可。例如假设要修改Wheel的逻辑，只需要修改Visitor的visit(Wheel wheel)方法即可。 2、假设我们又需要新增一个汽车元素天窗的话，只需要在visitor中添加新的接口以处理新元素，而别的元素可以保持不动。 违背开闭原则。 3、当我们需要添加新的业务操作，只需要添加新的具体访问者，其他的依旧可以保持不变。符合开闭原则。 同样，有好处也就有缺陷，因为逻辑在visitor里面，所有visitor和Element高度耦合，同样针对visit方法返回类型，需要设计的优雅，如若不然，后期一旦修改返回类型，影响的范围就广，所有访问者接口和实现都波及到。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问，这一点跟迪米特法则和依赖倒置原则相违背。 总的而言，访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。 JDK中含有的访问者模式提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。 javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor 参考访问者模式|菜鸟教程 Visitor pattern JAVA设计模式（23）：行为型-访问者模式（Visitor）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计模式原则]]></title>
    <url>%2F2019%2F01%2F05%2Fprinciples-of-software-design-patterns%2F</url>
    <content type="text"><![CDATA[软件设计模式原则在我们面向对象的设计过程中，我们的code既要可读性高方便维护，同时还需要另外一个可复用性。这次我们来学习软件设计模式中涉及到的一些原则————&gt;面向对象设计 SOLID 这就是吐槽： 但是我们往往接手的项目，都是苦不堪言，一把鼻涕一把泪，看前人留下的杰作，那是相当痛苦，千万匹MMP奔腾，填坑，还技术债。 入正题，在有些说七大原则，有些说六大原则，有些说五大原则，但是最重要的就是SOLID了。 国内的博文大部分都说七大和六大原则，Google下solid，看老外的文章和wiki都是五大原则。 我们先看SOLID，是罗伯特·C·马丁搞出来的首字母缩写记忆，这个Bob大叔。 Single Responsibility Principle：单一职责原则，解释：一个类只负责一个功能领域中的相应职责 Open Closed Principle：开闭原则，解释：软件实体应对扩展开放，而对修改关闭 Liskov Substitution Principle：里氏替换原则，解释：所有引用基类对象的地方能够透明地使用其子类的对象 Interface Segregation Principle：接口隔离原则，解释：使用多个专门的接口，而不使用单一的总接口 Dependence Inversion Principle：依赖倒置原则，解释：抽象不应该依赖于细节，细节应该依赖于抽象 剩下的两大原则 Composite Reuse Principle 合成复用原则，解释：尽量使用对象组合，而不是继承来达到复用的目的 Law of Demeter 迪米特法则，解释：一个软件实体应当尽可能少地与其他实体发生相互作用 单一职责原则 a class should have only a single responsibility (i.e. only changes to one part of the software’s specification should be able to affect the specification of the class). 顾名思义，就是一个类只负责一个职责。不能有多个导致类变更的原因。 让类的职责单一，只需要负责自己部分，复杂度就会降低，代码维护起来也更加容易。原则不仅仅适用于类，对于接口和方法也适用，即一个接口/方法，只负责一件事，这样的话，接口就会变得简单，方法中的代码也会更少，易读，便于维护。事实上，由于一些其他的因素影响，类的单一职责在项目中是很难保证的。通常，接口和方法的单一职责更容易实现。 好处： 代码的粒度降低了，类的复杂度降低了。 可读性提高了，每个类的职责都很明确，可读性自然更好。 可维护性提高了，可读性提高了，一旦出现 bug ，自然更容易找到他问题所在。 改动代码所消耗的资源降低了，更改的风险也降低了。 高内聚、低耦合 假设有一类C，含有logging、order、pay3个方法，实则就这个类就不是单一指责了，按要求后我们保留单一指责order方法。后期需求来了，我们要对order方法进行修改，产生了order1和order2，尽量在方法级别保留了单一指责，或者这个时候修改为类C1和C2，都有order方法。这两种方法，我们往往选择前者较多，但是有些2者都不选择，直接就在类C中order方法进行修改，支持多种需求，在这一步就违法单一指责。需求有可能在未来导致order方法扩散到n个。记住，在指责扩散到无法控制时，一定要重构。 开闭原则 software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. 软件实体如类、模块、方法等对于扩展开放的，但是对于修改封闭的。 我们试想一下，产品来需求了，对我们原有的代码要进行升级或者改变的时候，可能我们在修改旧的业务代码时，往往也会新增新的bug，这个时候，有可能因为功能复杂情况下要对整个功能进行重构。这个时候，就应该想到开闭原则，通过扩展实现改变而不是修改原有的东西。 有没有感觉，对扩展开放，对修改关闭。说起来很简单，感觉像啥也没说一样，具体起来该如何做。 Open–closed principle中一文有描述，通过继承抽象类和实现接口。 其实，这也正是我们面向对象中的框架设计—–抽象，用抽象构建框架，用实现扩展细节。我们队框架进行关闭，通过实现细节进行开放。而我们的业务常常就是这些细节，通过细节的实现，我们就能完成扩展。但是前提是我们的框架要足够抽象化，具有针对需求的满足性，要有足够的预埋性，这其实也是需要一定的经验。 里氏替换原则 objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. 程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。简单点，就是我用基类代替子类的话，程序还是一样的，是对的。 Liskov substitution principle有讲明里氏替换原则的来路。Barbara Liskov女士提出来的。 PDF中有相关的介绍 是这么定义的： 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 通俗点理解： 例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在使用里氏代换原则时需要注意如下几个问题： (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 12345678910111213class A&#123; public int func1(int a, int b)&#123; return a-b; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); System.out.println("100-50="+a.func1(100, 50)); System.out.println("100-80="+a.func1(100, 80)); &#125;&#125; 运行结果： 100-50=50 100-80=20 123456789101112131415161718class B extends A&#123; public int func1(int a, int b)&#123; return a+b; &#125; public int func2(int a, int b)&#123; return func1(a,b)+100; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; B b = new B(); System.out.println("100-50="+b.func1(100, 50)); System.out.println("100-80="+b.func1(100, 80)); System.out.println("100+20+100="+b.func2(100, 20)); &#125;&#125; 类B完成后，运行结果： 100-50=150 100-80=180 100+20+100=220 通过这个举例可以看出子类改变了父类原有的功能，子类无意或者有意重写了父类的方法。导致本来的减法变成了加法。 接口隔离原则 many client-specific interfaces are better than one general-purpose interface. 多个特定客户端接口要好于一个宽泛用途的接口。 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。将一个庞大的接口变更为多个专用的接口所采用的就是接口隔离原则。 例如：接口I有5个方法M1,M2,M3,M4,M5，假设现在有3个实现类C1实现5分方法，实现类C2只实现前面3个方法M1,M2,M3其他2个则是空实现，实现类C3只实现M4,M5其他3个则是空实现。这个时候就体现出接口庞大了。此时应将接口I拆分成接口I1有方法M1,M2,M3，接口I2有方法M4,M5。而实现类C1实现接口I1和I2，实现类C2实现接口I1，实现类C3实现接口I2。 接口隔离原则跟单一职责原则很相似。其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 依赖倒置原则 one should “depend upon abstractions, [not] concretions. 依赖于抽象而不是一个实例。其实想想依赖注入是该原则的一种实现方式。 The principle states: High-level modules should not depend on low-level modules. Both should depend on abstractions). Abstractions should not depend on details. Details should depend on abstractions. 翻译过来是：高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节。细节应该依赖抽象。 在Java语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。接口或抽象类不依赖于实现类。实现类依赖于接口或抽象类。 简而言之，尽可能的使用接口或者抽象类，即所谓的面向接口编程。 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 这张图，其实就很好的表达了依赖倒置原则，ObjectB应该依赖InterfaceA去申明ObjectA而非直接去依赖ObjectA，而ObjectA也应该依赖InterfaceA，这就是高层模块不应该依赖底层模块，两者都应该依赖其抽象和细节应该依赖抽象。 我们来看看如下的示例，刚开始，学生只是简单的完成学校里的白天课堂作业。 12345678910111213141516public class SchoolWork &#123; public void work() &#123; System.out.println("学生每天在学校就完成课堂作业了"); &#125;&#125;public class Student &#123; public void work(SchoolWork schoolWork) &#123; schoolWork.work(); &#125;&#125;//客户端调用Student student = new Student();SchoolWork work = new SchoolWork();student.work(work); 我们发现，学生每天都在课堂上就完成了作业，但是随着时间慢慢的过去，学生们，课堂作业变多了，老师开始布置家庭作业了。那么Student类中再写一个写家庭作业的方法嘛，万一老师又给学生布置其他作业又写一种方法吗，肯定不是的啦。 这个时候就需要把作业抽象起来了，用接口或者抽象类都可以。 12345678910111213141516171819202122232425262728public interface Work &#123; public void work();&#125;public class SchoolWork implements Work &#123; public void work() &#123; System.out.println("学生每天在学校就完成课堂作业了"); &#125;&#125;public class HomeWork implements Work &#123; public void work() &#123; System.out.println("学生每天在家就完成家庭作业了"); &#125;&#125;public class Student &#123; public void work(Work work) &#123; work.work(); &#125;&#125;//客户端调用Student student = new Student();Work work = new SchoolWork();student.work(work);work = new HomeWork();student.work(work); 这就是面向接口编程。Work work = new SchoolWork();和work = new HomeWork();就是变量的声明类型尽量是抽象类或者接口。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 迪米特法则From Wikipedia, the free encyclopedia Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.Each unit should only talk to its friends; don’t talk to strangers.Only talk to your immediate friends. 每个单位对其他单位的了解应该是有限，除了跟自己相对密切的单位。的不要和陌生人说话啊，只与直接的朋友通信。 看完之后，是不是云里雾里，不知道说什么鸟语花香。其实就是，一个对象应该对其他对象保持最少的了解。啊，你还是不知道它说了个啥。通俗的讲就是一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类，向外公开的方法应该尽可能的少(尽可能的不用用public修饰方法)。对于上面的朋友的定义来讲，两个对象之间的耦合关系称之为朋友，通常有依赖、关联、聚合和组成等。而直接朋友则通常表现为关联、聚合和组成关系，即两个对象之间联系更为紧密，通常以成员变量、方法的参数和返回值的形式出现。同时了陌生的类最好不要作为局部变量的形式出现在类的内部。 朋友了也是有这样几种定义的 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象，如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。 来看个示例，关计算机的业务。 主要是针对只暴露应该暴露的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//计算机类public class Computer&#123; public void saveCurrentTask()&#123; //do something &#125; public void closeService()&#123; //do something &#125; public void closeScreen()&#123; //do something &#125; public void closePower()&#123; //do something &#125; public void close()&#123; saveCurrentTask(); closeService(); closeScreen(); closePower(); &#125;&#125;//人public class Person&#123; private Computer c; ... public void clickCloseButton()&#123; //现在你要开始关闭计算机了，正常来说你只需要调用close（）方法即可， //但是你发现Computer所有的方法都是公开的，该怎么关闭呢？于是你写下了以下关闭的流程： c.saveCurrentTask(); c.closePower(); c.close(); //亦或是以下的操作 c.closePower(); //还可能是以下的操作 c.close(); c.closePower(); &#125;&#125; 从被依赖者的角度，只应该暴露应该暴露的方法。那么这里的c对象应该哪些方法应该是被暴露的呢？很显然，对于Person来说，只需要关注计算机的关闭操作，而不关心计算机会如何处理这个关闭操作，因此只需要暴露close（）方法即可。 1234567891011121314151617181920212223242526272829303132333435//计算机类public class Computer&#123; private void saveCurrentTask()&#123; //do something &#125; private void closeService()&#123; //do something &#125; private void closeScreen()&#123; //do something &#125; private void closePower()&#123; //do something &#125; public void close()&#123; saveCurrentTask(); closeService(); closeScreen(); closePower(); &#125;&#125;//人public class Person&#123; private Computer c; ... public void clickCloseButton()&#123; c.close(); &#125;&#125; 再来看一个示例，只依赖应该依赖的对象 123456789101112131415161718192021222324252627282930313233343536373839public class A &#123; public D do(B b) &#123; C c = b.getC().; c.doSomething(); D d = c.getResult() return d; &#125;&#125;@Datapublic class B &#123; private C c;&#125;@Datapublic class C &#123; public void doSomething() &#123; //..... &#125; public D getResult() &#123; //..... return new D(); &#125;&#125;@Datapublic class D &#123; //.......&#125;public class Client &#123; public void main(String[] args) &#123; A a = new A(); B b = new B(); System.out.println(a.do(b)); &#125;&#125; 从上述例子中，可以看出，在A类的do方法中，类C其实相对于类A来说就是陌生人，高耦合在A类中。假设日后，我们对C类的doSomething和getResult方法改动时，就会影响到类A。 至于如何修改，想看看看官们有什么建议或者实现，欢迎留言。 总的来说，在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。高内聚，低耦合。 合成复用原则也称为合成/聚合复用原则，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 其原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。 如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 聚合（Aggregation）表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象但B对象不是A对象的一部分。如上图中的大雁属于雁群的，一个雁群是有很多大雁。聚合关系用空心的菱形+实线来表示。 合成（Composition）则是一种强的’拥有’关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。例如上图大雁人是有头、翅膀等合成的，大雁和头、翅膀的生命周期是一样的，大家一起玩完。合成关系用实心的菱形+实线来表示。 通常类的复用分为继承复用和合成复用 两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 总结单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 参考SOLID Design Principles Explained The SOLID Principles in Real Life S.O.L.I.D: The First 5 Principles of Object Oriented Design SOLID 设计模式六大原则——SOLID 软件设计模式六大原则 浅谈 SOLID 原则的具体使用 白话设计——浅谈迪米特法则 合成复用原则——面向对象设计原则]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之迭代器模式]]></title>
    <url>%2F2019%2F01%2F02%2Fdesign-pattern-iterator%2F</url>
    <content type="text"><![CDATA[迭代器模式 Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 提供一种不公示其底层细节(结构)的情况下能顺序访问聚合对象元素的方法。其实在java体系中，jdk已经引入了迭代器接口以及对于的容器接口等。就拿迭代器中的角色，在java中找出其对应的类。 具体角色 (1)迭代器角色(Iterator)：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法next()，判断是否遍历结束的方法hasNext()），移出当前对象的方法remove(), (2)具体迭代器角色(Concrete Iterator)：实现迭代器接口中定义的方法，完成集合的迭代。 (3)容器角色(Aggregate): 一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等 (4)具体容器角色(ConcreteAggregate)：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。 单独举出ArrayList的角色， 迭代器角色对应java中的java.lang.Iterator，这个迭代器是java容器公用的。 容器角色对应java.lang.Iterable，其还有Iterator iterator()方法获取迭代器。 具体迭代器角色对应java.lang.ArrayList.Itr，实现了对应的hasNext、next、remove方法。 具体容器角色那就是java.lang.ArrayList了，实现iterator方法返回Itr具体迭代器，用游标形式实现。 再看看UML类 项目实例源码在Github 项目中很简单的实现了一个容器和迭代器。大致参考了ArrayList实现，但是是简洁版本，去除很多无关以及性能上的东西，只保留最基本的迭代器元素。 12345678910111213141516@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Aggregate&lt;Integer&gt; aggregate = new ConcreteAggregate&lt;&gt;(); aggregate.add(1); aggregate.add(2); aggregate.add(3); aggregate.add(4); Iterator&lt;Integer&gt; iterator = aggregate.iterator(); while (iterator.hasNext()) &#123; log.info("循环数据&#123;&#125;", iterator.next()); &#125; &#125;&#125; 执行结果如下 简单的迭代器定义 1234567public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next();&#125; 简单容器定义 1234567public interface Aggregate&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); void add(T t);&#125; 具体容器和具体的迭代器定义 123456789101112131415161718192021222324252627282930313233343536373839404142public class ConcreteAggregate&lt;E&gt; implements Aggregate&lt;E&gt; &#123; private Object[] elements; private int size = 0; public ConcreteAggregate() &#123; elements = new Object[16]; &#125; public int getSize() &#123; return size; &#125; public void add(E e) &#123; elements[size++] = e; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ConcreteIterator&lt;E&gt;(); &#125; private class ConcreteIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; int cursor; @Override public boolean hasNext() &#123; return cursor != size; &#125; @Override public E next() &#123; if (cursor &gt;= size) &#123; return null; &#125; return (E) elements[cursor++]; &#125; &#125;&#125; 具体容器中用数组来作为容器来存储元素，而且最简单的容器，固定了大小，并没有实现扩容的算法等等，只是一个简单的样例，但是大部分上，都是直接使用java带有的迭代器。 优点 简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。 可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。 封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。 缺点由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。 总结迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。 参考wiki的迭代器模式 迭代器模式|菜鸟教程 Java设计模式系列之迭代器模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之命令模式]]></title>
    <url>%2F2019%2F01%2F02%2Fdesign-pattern-command%2F</url>
    <content type="text"><![CDATA[命令模式 wiki上的描述 Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests, and the queuing or logging of requests. It also allows for the support of undoable operations. 翻译意思，把请求封装成一个对象，从而允许我们可以对客户端的不同请求进行参数化，以及对请求进行排队或记录。还允许支持撤销操作。看起来好像很复杂，很难理解。 通俗简单理解，它就是将请求封装成一个对象，在这里就是这个对象就是命令，而这个命令就是将请求方和执行方分离隔开。从而每一个命令其实就是操作，而这样的流程就是请求方发出请求要求执行某操作，接收方收到请求后并执行对应的操作。这样下来，请求方和接收方就解耦了，使得请求方完全不知道接受的操作方法，从也不会知道接收方是何时接受到请求的，又是何时执行操作的，又是怎么执行操作的。 具体的角色 Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。 ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。 Invoker（请求方）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。 Receiver（接收方）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。 Client（客户端）：创建具体命令的对象并且设置命令对象的接受者。 再来看看UML图 从上方的时序图中可以看出运行的顺序，Invoker执行execute方法，调用Command1对象，Command1执行action1方法调用Receiver1对象。 干货代码源码在我的GitHub地址 普通的命令模式现在结合下上回说到的状态模式一起来实现这个风扇的左转和右转功能，这次把他用命令模式来代替之前风扇的转动，把它当做命令来。 客户端简单的定义请求方和接收方以及对于的左转命令和右转命令，设置命令后对应的执行命令。 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.setCommand(leftCommand); invoker.execute(); invoker.execute(); &#125;&#125; 请求方 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125;&#125; 抽象命令 1234public interface Command &#123; void execute();&#125; 开关左转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125;&#125; 开关右转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 通过命令模式把左转和右转封装成命令，以及之前的状态模式变更风扇的状态。本次就是通过状态模式和命令模式实现了一个风扇开关左右转的功能。 宏命令或者叫做组合命令设计一组命令，简单的处理事情，打印一句话，封装成一组命令。这次我们用了Java8来写，可以使用lambda。 12345678910111213141516171819202122232425262728@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); log.info("初始化ABC3个命令"); Command aCommand = () -&gt; log.info("A处理这个请求"); invoker.addCommand(aCommand); invoker.addCommand(() -&gt; log.info("B处理这个请求")); invoker.addCommand(() -&gt; log.info("C处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令D"); invoker.addCommand(() -&gt; log.info("D处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令E"); invoker.addCommand(() -&gt; log.info("E处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("移除命令A"); invoker.removeCommand(aCommand); invoker.execute(); &#125;&#125; 打印语句。 抽象命令 12345@FunctionalInterfacepublic interface Command &#123; void execute();&#125; 请求方 1234567891011121314151617181920212223@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private List&lt;Command&gt; commandList = Lists.newArrayList(); public void addCommand(Command command) &#123; commandList.add(command); &#125; public void removeCommand(Command command) &#123; commandList.remove(command); &#125; public void execute() &#123; if(CollectionUtils.isEmpty(commandList)) &#123; return; &#125; commandList.stream().forEach(command -&gt; command.execute()); &#125;&#125; 撤销操作在普通的命令模式的基础上，增加了撤销操作，在这里的撤销操作，其实即为左转时的右转，右转时的左转。 123456789101112131415161718192021@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.undo(); invoker.undo(); invoker.setCommand(leftCommand); invoker.execute(); invoker.undo(); &#125;&#125; 抽象命令增加了撤销操作 123456public interface Command &#123; void execute(); void undo();&#125; 具体左转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125; @Override public void undo() &#123; receiver.right(); &#125;&#125; 右转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125; @Override public void undo() &#123; receiver.left(); &#125;&#125; 请求方 12345678910111213141516@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125; public void undo() &#123; command.undo(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 命令模式总结优点 (1) 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 (2) 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 (3) 可以比较容易地设计一个命令队列或宏命令（组合命令）。 (4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。 适用场景 (1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 (2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 (3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 (4) 系统需要将一组操作组合在一起形成宏命令。 (5)线程池有一个addTash方法，将任务添加到待完成的队列中，队列中的元素就是命令对象，通常的就是一个公共接口，像我们常用的java.lang.Runnable接口。 (6)java8之后，最好在Command接口中@FunctionalInterface修饰，这样具体的命令就可以使用lambda表达式啦。 Java中的使用将操作封装到对象内，以便存储，传递和返回。 java.lang.Runnable javax.swing.Action 文章参考java设计模式之命令模式 细数JDK里的设计模式 wiki的命令模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之状态模式]]></title>
    <url>%2F2018%2F12%2F24%2Fdesign-pattern-state%2F</url>
    <content type="text"><![CDATA[状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。通俗点就是一个对象在内部状态发生改变时改变它的行为。 介绍意图 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用 代码中包含大量与对象状态有关的条件语句。 如何解决 将各种具体的状态类抽象出来。 关键代码 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 UML图 主要角色 1）Context(环境类)：环境类拥有各种不同状态的对象，作为外部使用的接口，负责调用状态类接口。 2）State(抽象状态)：抽象状态既可以为抽象类，也可以直接定义成接口。主要用于定义状态抽象方法，具体实现由子类负责。 3）ConcreteState(具体状态类):具体状态类为抽象状态的实现者，不同的状态类对应这不同的状态，其内部实现也不相同。环境类中使用不同状态的对象时，能实现不同的处理逻辑 应用实例 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景 行为随状态改变而改变的场景。 条件、分支语句的代替者。 状态模式和策略模式的对比现在我们知道，状态模式和策略模式的结构是相似的，但它们的意图不同。让我们重温一下它们的主要不同之处： 策略模式封装了一组相关算法，它允许Client在运行时使用可互换的行为；状态模式帮助一个类在不同的状态显示不同的行为。 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而通过从Context中分离出策略或算法，我们可以重用它们。 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。 策略实现可以作为参数传递给使用它的对象，例如Collections.sort()，它的参数包含一个Comparator策略。另一方面，状态是Context对象自己的一部分，随着时间的推移，Context对象从一个状态转移到另一个状态。 虽然它们都符合OCP原则，策略模式也符合SRP原则（单一职责原则），因为每个策略都封装自己的算法，且不依赖其他策略。一个策略的改变，并不会导致其他策略的变化。 另一个理论上的不同：策略模式定义了对象“怎么做”的部分。例如，排序对象怎么对数据排序。状态模式定义了对象“是什么”和“什么时候做”的部分。例如，对象处于什么状态，什么时候处在某个特定的状态。 状态模式中很好的定义了状态转移的次序；而策略模式并无此需要：Client可以自由的选择任何策略。 一些常见的策略模式的例子是封装算法，例如排序算法，加密算法或者压缩算法。如果你看到你的代码需要使用不同类型的相关算法，那么考虑使用策略模式吧。而识别何时使用状态模式是很简单的：如果你需要管理状态和状态转移，但不想使用大量嵌套的条件语句，那么就是它了。 最后但最重要的一个不同之处是，策略的改变由Client完成；而状态的改变，由Context或状态自己。 项目实例跳转到我的源码地址 simple1包中主要是对风扇的开关状态进行转换，其实我们是把状态放在状态类中进行按照固定的逻辑转换，但是这种模式其实他不符合开闭原则，为什么了，因为一旦我们发生新增、修改或者删除状态的时候，就需要修改状态类中的状态转换。 123456789101112public class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new CloseLevelState()); context.right(); context.right(); context.right(); context.left(); context.right(); context.right(); &#125;&#125; 抽象状态 12345678910111213141516171819202122public interface LevelState &#123; /** * 左转 * * @param context */ void left(Context context); /** * 右转 * * @param context */ void right(Context context); /** * 当前档位 * @return */ String info();&#125; 具体档位状态，我只列了2个，其他的类似 12345678910111213141516171819202122@Slf4jpublic class OneLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new CloseLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new TwoLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "1档"; &#125;&#125; 1234567891011121314151617181920212223@Slf4jpublic class CloseLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new ForeLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new OneLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "0档"; &#125;&#125; 真正的开关也就是上下文 123456789101112131415161718@Data@AllArgsConstructorpublic class Context &#123; private LevelState levelState; public void left() &#123; levelState.left(this); &#125; public void right() &#123; levelState.right(this); &#125; public String info() &#123; return levelState.info(); &#125;&#125; 参考Java中，状态模式和策略模式的区别 状态模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之责任链模式]]></title>
    <url>%2F2018%2F12%2F21%2Fdesign-pattern-chain%2F</url>
    <content type="text"><![CDATA[责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 简介意图 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用 在处理消息的时候以过滤很多道。 如何解决 拦截的类都实现统一接口。 关键代码 Handler 里面聚合它自己，在 handleRequest 里判断是否合适，如果没达到条件则向下传递。 纯责任链与不纯责任链 纯：纯责任链中的节点只有两种行为，一处理责任，二将责任传递到下一个节点。不允许出现某一个节点处理部分或全部责任后又将责任向下传递的情况。 不纯：允许某个请求被一个节点处理部分责任后再向下传递，或者处理完后其后续节点可以继续处理该责任，而且一个责任可以最终不被任何节点所处理。 主要角色 Handler（抽象处理者）： 定义一个处理请求的接口，提供对后续处理者的引用 ConcreteHandler（具体处理者）： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发 应用实例 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 Github项目描述跳转到我的责任链设计模式源码 1.出行方式travel包里主要对出行方式的责任链模式。跟进用户身上的钱，在优先级如飞机-&gt;火车-&gt;大巴的顺序下选择对应的出行模式。 123456789101112131415public class Application &#123; public static void main(String[] args) &#123; Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); planeHandler.setNext(trainHandler); trainHandler.setNext(busHandler); planeHandler.handleRequest("老王", 40d); planeHandler.handleRequest("张三", 140d); planeHandler.handleRequest("李四", 240d); planeHandler.handleRequest("吴老五", 340d); &#125;&#125; 抽象处理 12345678910@Datapublic abstract class Handler &#123; /** * 下一个链节点 */ protected Handler next; public abstract void handleRequest(String name, Double wallet);&#125; 具体的处理者（飞机、火车、大巴） 123456789101112131415161718@Slf4jpublic class PlaneHandler extends Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class TrainHandler extends Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class BusHandler extends Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 2.出行方式2，参考Filter链的写法travel2包是对travel包的重新写法。 1234567891011121314151617public class Application &#123; public static void main(String[] args) &#123; HandlerChain chain = new HandlerChain(); Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); chain.addHandler(planeHandler); chain.addHandler(trainHandler); chain.addHandler(busHandler); chain.handle("老王", 40d); chain.handle("张三", 140d); chain.handle("李四", 240d); chain.handle("吴老五", 340d); &#125;&#125; 抽象处理者 1234public interface Handler &#123; void handleRequest(String name, Double wallet, HandlerChain chain);&#125; 具体处理者（飞机、火车、大巴） 123456789101112131415@Slf4jpublic class PlaneHandler implements Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class TrainHandler implements Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class BusHandler implements Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 责任链管理者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Slf4jpublic class HandlerChain &#123; private List&lt;Handler&gt; handlerList = new ArrayList&lt;&gt;(); /** * 维护当前链上位置 */ private int pos; /** * 链的长度 */ private int handlerLength; public void addHandler(Handler handler) &#123; handlerList.add(handler); handlerLength = handlerList.size(); &#125; public void handle(String name, double wallet) &#123; if (CollectionUtils.isEmpty(handlerList)) &#123; log.error("有钱，但没提供服务，&#123;&#125;也估计就只能步行了。", name); return; &#125; if (pos &gt;= handlerLength) &#123; log.error("身上钱不够，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; Handler handler = handlerList.get(pos++); if (Objects.isNull(handler)) &#123; log.error("假服务，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; handler.handleRequest(name, wallet, this); &#125; /** * 链重新使用 */ public void reuse() &#123; pos = 0; &#125;&#125; 学习Web项目的Filter待补充… 补充补充遗留的Filter过滤器中的责任链处理。 本次主要是对Tomcat中的Filter处理简单的梳理，如有不正确的地方，还望指出来，大家互勉，共进。 老项目大家可以在web.xml中配置filter，现使用Springboot后，也有两种配置filter方式，通过创建FilterRegistrationBean的方式和通过注解@WebFilter+@ServletComponentScan的方式。 三个主要的角色 FIlter，不多介绍了。 FilterChain servlet容器提供的开发调用链的过滤请求的资源。通过调用下一个filter实现过滤，在整体链上。 FilterConfig filter的配置器，在servlet容器在Filter初始化的时候传递信息。 具体的filter，主要说说Spring中的两个抽象Filter，GenericFilterBean和OncePerRequestFilter。 前者主要是做init和destroy的操作，重点还是init方法，destroy只是空实现而已。 后者主要是做真正的doFilter操作，也是我们在Spring中创建Filter通常继承的。 而ApplicationFilterChain就算Tomcat中的FilterChain实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 /** * The int which is used to maintain the current position * in the filter chain. */ private int pos = 0; /** * The int which gives the current number of filters in the chain. */ private int n = 0;@Overridepublic void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //安全相关的，暂不关注 if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; try &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123; @Override public Void run() throws ServletException, IOException &#123; internalDoFilter(req,res); return null; &#125; &#125; ); &#125; catch( PrivilegedActionException pe) &#123; Exception e = pe.getException(); if (e instanceof ServletException) throw (ServletException) e; else if (e instanceof IOException) throw (IOException) e; else if (e instanceof RuntimeException) throw (RuntimeException) e; else throw new ServletException(e.getMessage(), e); &#125; &#125; else &#123; //真正的doFilter internalDoFilter(request,response); &#125;&#125;private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //pos 调用链中当前连接点所在的位置 //n 调用链总节点长度 // Call the next filter if there is one if (pos &lt; n) &#123; //对节点进行自增 pos++ ApplicationFilterConfig filterConfig = filters[pos++]; try &#123; //当前节点小于总长度后，从filter配置类中取出filter Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() &amp;&amp; "false".equalsIgnoreCase( filterConfig.getFilterDef().getAsyncSupported())) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res, this&#125;; SecurityUtil.doAsPrivilege ("doFilter", filter, classType, args, principal); &#125; else &#123; //真正的filter filter.doFilter(request, response, this); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.filter"), e); &#125; return; &#125; // We fell off the end of the chain -- call the servlet instance //到了调用链结尾处，就真正调用servlet实例的servlet.service(request, response); try &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // Use potentially wrapped request from this point if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res&#125;; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args, principal); &#125; else &#123; servlet.service(request, response); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.servlet"), e); &#125; finally &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(null); lastServicedResponse.set(null); &#125; &#125;&#125;/*** Prepare for reuse of the filters and wrapper executed by this chain.* 重复使用filter调用链，pos重设为0*/void reuse() &#123; pos = 0;&#125; 重点从ApplicationFilterChain中挑出几个重要的方法拿出来分析下Filter的调用链，其实还有几处没有具体讲到，ApplicationFilterChain是合适创建的，Filter是怎么加入到ApplicationFilterChain中的。这涉及到Tomcat是怎样加载Content的，下次分析Tomcat的时候，再来具体分析，它是如何运作的，如何加载web.xml。 参考维基的责任链模式 责任链模式|菜鸟教程 Filter、FilterConfig、FilterChain|菜鸟教程 南乡清水的实际项目运用之Responsibility-Chain模式 一起学设计模式 - 责任链模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之策略模式]]></title>
    <url>%2F2018%2F12%2F20%2Fdesign-pattern-strategy%2F</url>
    <content type="text"><![CDATA[策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。简单理解就是一组算法，可以互换，再简单点策略就是封装算法。 意图 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用 一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决 将这些算法封装成一个一个的类，任意地替换。 主要角色 上下文Context，拥有一个Strategy的引用 抽象策略Strategy，往往是一个接口(占大部分情况)或者抽象类，通常提供各种具体策略的接口 具体策略，这就是重点了，封装了各种具体的算法 UML 应用实例 诸葛亮的锦囊妙计，每一个锦囊就是一个策略； 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略； JAVA AWT 中的 LayoutManager； 优点 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 项目描述跳转到我的策略模式GitHub 1.操作行为simple1包，主要对操作行为包装了加减乘除方法。 1234567891011121314151617@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new AddStrategy()); log.info("10 + 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new SubstractStrategy()); log.info("10 - 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new MultiplyStrategy()); log.info("10 * 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new DivideStrategy()); log.info("10 / 5 = &#123;&#125;", context.executeStrategy(10, 5)); &#125;&#125; 执行结果 2.出现方式simple2包描述，主要对出行方式的包装，包装了3种出行方式， 执行类 12345678910111213public class TravelApplication &#123; public static void main(String[] args) &#123; Context context = new Context(new BusStrategy()); context.executeStrategy("老王"); context.setStrategy(new BicycleStrategy()); context.executeStrategy("老张"); context.setStrategy(new WalkStrategy()); context.executeStrategy("老李"); &#125;&#125; 执行结果 策略上下文 12345678910111213141516171819@Datapublic class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 出行 * * @return */ public void executeStrategy(String name) &#123; strategy.travel(name); &#125;&#125; 抽象策略 123456789public interface Strategy &#123; /** * 出现方法 * * @return */ void travel(String name);&#125; 参考策略模式|菜鸟教程 维基里的策略模式 南乡清水的实际项目运用之Strategy模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式汇总]]></title>
    <url>%2F2018%2F12%2F19%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[设计模式23种设计模式大纲… 软件设计模式原则 构建模式 Builder （建造者模式） Abstract Factory （抽象工厂模式） Factory Method （工厂方法） Prototype （原型模式） Singleton （单例模式） 结构模式 Adapter （适配器模式） Bridge （桥接模式） Composite （组合模式） Decorator （装饰模式） Facade （外观模式） Flyweight （享元模式） Proxy （代理模式） 行为模式 Chain of Responsibility（责任链模式） Command （命令模式） Interpreter （解释器模式） Iterator（迭代器模式） Mediator（中介者模式） Memento（备忘录模式） Observer（观察者模式） State（状态模式） Strategy (策略模式) Template Method （模板方法） Visitor（访问者模式）]]></content>
      <categories>
        <category>设计模式</category>
        <category>汇总</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试评论]]></title>
    <url>%2F2018%2F12%2F18%2Ftest%2F</url>
    <content type="text"><![CDATA[测试评论]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
