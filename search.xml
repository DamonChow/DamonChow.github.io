<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里巴巴开源分布式事务解决方案 FESCAR【转】]]></title>
    <url>%2F2019%2F01%2F13%2Ffescar%2F</url>
    <content type="text"><![CDATA[偶然间看到阿里开源的分布式事务中间件，期待有投入到生产阶段的栗子。从蓝图上看出目前有支持dubbo的解决方案，后续0.5.x版本会推出支持spring cloud的方案。 下面看官方正文，喜欢的可以去官方Github上瞧瞧看看。 Fescar 是 阿里巴巴 开源的 分布式事务中间件，以 高效 并且对业务 0 侵入 的方式，解决 微服务 场景下面临的分布式事务问题。 1. 什么是微服务化带来的分布式事务问题？首先，设想一个传统的单体应用（Monolithic App），通过 3 个 Module，在同一个数据源上更新数据来完成一项业务。 很自然的，整个业务过程的数据一致性由本地事务来保证。 随着业务需求和架构的变化，单体应用被拆分为微服务：原来的 3 个 Module 被拆分为 3 个独立的服务，分别使用独立的数据源（Pattern: Database per service）。业务过程将由 3 个服务的调用来完成。 此时，每一个服务内部的数据一致性仍有本地事务来保证。而整个业务层面的全局数据一致性要如何保障呢？这就是微服务架构下面临的，典型的分布式事务需求：我们需要一个分布式事务的解决方案保障业务全局的数据一致性。 2. Fescar 的发展历程阿里是国内最早一批进行应用分布式（微服务化）改造的企业，所以很早就遇到微服务架构下的分布式事务问题。 2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。 2016 年，TXC 经过产品化改造，以 GTS（Global Transaction Service）的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品，在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。 2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast &amp; EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。 TXC/GTS/Fescar 一脉相承，为解决微服务架构下的分布式事务问题交出了一份与众不同的答卷。 2.1 设计初衷高速增长的互联网时代，快速试错 的能力对业务来说是至关重要的： 一方面，不应该因为技术架构上的微服务化和分布式事务支持的引入，给业务层面带来额外的研发负担。 另一方面，引入分布式事务支持的业务应该基本保持在同一量级上的性能表现，不能因为事务机制显著拖慢业务。 基于这两点，我们设计之初的最重要的考量就在于： 对业务无侵入： 这里的 侵入 是指，因为分布式事务这个技术问题的制约，要求应用在业务层面进行设计和改造。这种设计和改造往往会给应用带来很高的研发和维护成本。我们希望把分布式事务问题在 中间件 这个层次解决掉，不要求应用在业务层面做额外的工作。 高性能： 引入分布式事务的保障，必然会有额外的开销，引起性能的下降。我们希望把分布式事务引入的性能损耗降到非常低的水平，让应用不因为分布式事务的引入导致业务的可用性受影响。 2.2 既有的解决方案为什么不满足？既有的分布式事务解决方案按照对业务侵入性分为两类，即：对业务无侵入的和对业务有侵入的。 业务无侵入的方案既有的主流分布式事务解决方案中，对业务无侵入的只有基于 XA 的方案，但应用 XA 方案存在 3 个方面的问题： 要求数据库提供对 XA 的支持。如果遇到不支持 XA（或支持得不好，比如 MySQL 5.7 以前的版本）的数据库，则不能使用。 受协议本身的约束，事务资源的锁定周期长。长周期的资源锁定从业务层面来看，往往是不必要的，而因为事务资源的管理器是数据库本身，应用层无法插手。这样形成的局面就是，基于 XA 的应用往往性能会比较差，而且很难优化。 已经落地的基于 XA 的分布式解决方案，都依托于重量级的应用服务器（Tuxedo/WebLogic/WebSphere 等)，这是不适用于微服务架构的。 侵入业务的方案实际上，最初分布式事务只有 XA 这个唯一方案。XA 是完备的，但在实践过程中，由于种种原因（包含但不限于上面提到的 3 点）往往不得不放弃，转而从业务层面着手来解决分布式事务问题。比如： 基于可靠消息的最终一致性方案 TCC Saga 都属于这一类。这些方案的具体机制在这里不做展开，网上这方面的论述文章非常多。总之，这些方案都要求在应用的业务层面把分布式事务技术约束考虑到设计中，通常每一个服务都需要设计实现正向和反向的幂等接口。这样的设计约束，往往会导致很高的研发和维护成本。 2.3 理想的方案应该是什么样子？不可否认，侵入业务的分布式事务方案都经过大量实践验证，能有效解决问题，在各行种业的业务应用系统中起着重要作用。但回到原点来思考，这些方案的采用实际上都是 迫于无奈。设想，如果基于 XA 的方案能够不那么 重，并且能保证业务的性能需求，相信不会有人愿意把分布式事务问题拿到业务层面来解决。 一个理想的分布式事务解决方案应该：像使用 本地事务 一样简单，业务逻辑只关注业务层面的需求，不需要考虑事务机制上的约束。 3. 原理和设计我们要设计一个对业务无侵入的方案，所以从业务无侵入的 XA 方案来思考： 是否可以在 XA 的基础上演进，解决掉 XA 方案面临的问题呢？ 3.1 如何定义一个分布式事务？首先，很自然的，我们可以把一个分布式事务理解成一个包含了若干 分支事务 的 全局事务。全局事务 的职责是协调其下管辖的 分支事务 达成一致，要么一起成功提交，要么一起失败回滚。此外，通常 分支事务 本身就是一个满足 ACID 的 本地事务。这是我们对分布式事务结构的基本认识，与 XA 是一致的。 其次，与 XA 的模型类似，我们定义 3 个组件来协议分布式事务的处理过程。 Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。 Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。 Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。 一个典型的分布式事务过程： TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。 XID 在微服务调用链路的上下文中传播。 RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖。 TM 向 TC 发起针对 XID 的全局提交或回滚决议。 TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。 至此，Fescar 的协议机制总体上看与 XA 是一致的。 3.2 与 XA 的差别在什么地方？架构层次 XA 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身（通过提供支持 XA 的驱动程序来供应用使用）。 而 Fescar 的 RM 是以二方包的形式作为中间件层部署在应用程序这一侧的，不依赖与数据库本身对协议的支持，当然也不需要数据库支持 XA 协议。这点对于微服务化的架构来说是非常重要的：应用层不需要为本地事务和分布式事务两类不同场景来适配两套不同的数据库驱动。 这个设计，剥离了分布式事务方案对数据库在 协议支持 上的要求。 两阶段提交先来看一下 XA 的 2PC 过程。 无论 Phase2 的决议是 commit 还是 rollback，事务性资源的锁都要保持到 Phase2 完成才释放。 设想一个正常运行的业务，大概率是 90% 以上的事务最终应该是成功提交的，我们是否可以在 Phase1 就将本地事务提交呢？这样 90% 以上的情况下，可以省去 Phase2 持锁的时间，整体提高效率。 这个设计，在绝大多数场景减少了事务持锁时间，从而提高了事务的并发度。 当然，你肯定会问：Phase1 即提交的情况下，Phase2 如何回滚呢？ 3.3 分支事务如何提交和回滚？首先，应用需要使用 Fescar 的 JDBC 数据源代理，也就是 Fescar 的 RM。 Phase1： Fescar 的 JDBC 数据源代理通过对业务 SQL 的解析，把业务数据在更新前后的数据镜像组织成回滚日志，利用 本地事务 的 ACID 特性，将业务数据的更新和回滚日志的写入在同一个 本地事务 中提交。 这样，可以保证：任何提交的业务数据的更新一定有相应的回滚日志存在。 基于这样的机制，分支的本地事务便可以在全局事务的 Phase1 提交，马上释放本地事务锁定的资源。 Phase2： 如果决议是全局提交，此时分支事务此时已经完成提交，不需要同步协调处理（只需要异步清理回滚日志），Phase2 可以非常快速地完成。 如果决议是全局回滚，RM 收到协调器发来的回滚请求，通过 XID 和 Branch ID 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。 3.4 事务传播机制XID 是一个全局事务的唯一标识，事务传播机制要做的就是把 XID 在服务调用链路中传递下去，并绑定到服务的事务上下文中，这样，服务链路中的数据库更新操作，就都会向该 XID 代表的全局事务注册分支，纳入同一个全局事务的管辖。 基于这个机制，Fescar 是可以支持任何微服务 RPC 框架的。只要在特定框架中找到可以透明传播 XID 的机制即可，比如，Dubbo 的 Filter + RpcContext。 对应到 Java EE 规范和 Spring 定义的事务传播属性，Fescar 的支持如下： PROPAGATION_REQUIRED： 默认支持 PROPAGATION_SUPPORTS： 默认支持 PROPAGATION_MANDATORY：应用通过 API 来实现 PROPAGATION_REQUIRES_NEW：应用通过 API 来实现 PROPAGATION_NOT_SUPPORTED：应用通过 API 来实现 PROPAGATION_NEVER：应用通过 API 来实现 PROPAGATION_REQUIRED_NESTED：不支持 3.5 隔离性全局事务的隔离性是建立在分支事务的本地隔离级别基础之上的。 在数据库本地隔离级别 读已提交 或以上的前提下，Fescar 设计了由事务协调器维护的 全局写排他锁，来保证事务间的 写隔离，将全局事务默认定义在 读未提交 的隔离级别上。 我们对隔离级别的共识是：绝大部分应用在 读已提交 的隔离级别下工作是没有问题的。而实际上，这当中又有绝大多数的应用场景，实际上工作在 读未提交 的隔离级别下同样没有问题。 在极端场景下，应用如果需要达到全局的 读已提交，Fescar 也提供了相应的机制来达到目的。默认，Fescar 是工作在 读无提交 的隔离级别下，保证绝大多数场景的高效性。 事务的 ACID 属性在 Fescar 中的体现是一个比较复杂的话题，我们会有专门的文章来深入分析，这里不做进一步展开。 4. 适用场景分析前文所述的 Fescar 的核心原理中有一个 重要前提：分支事务中涉及的资源，必须 是支持 ACID 事务的 关系型数据库。分支的提交和回滚机制，都依赖于本地事务的保障。所以，如果应用使用的数据库是不支持事务的，或根本不是关系型数据库，就不适用。 另外，目前 Fescar 的实现还存在一些局限，比如：事务隔离级别最高支持到 读已提交 的水平，SQL 的解析还不能涵盖全部的语法等。 为了覆盖 Fescar 原生机制暂时不能支持应用场景，我们定义了另外一种工作模式。 上面介绍的 Fescar 原生工作模式称为 AT（Automatic Transaction）模式，这种模式是对业务无侵入的。与之相应的另外一种工作模式称为 MT（Manual Transaction）模式，这种模式下，分支事务需要应用自己来定义业务本身及提交和回滚的逻辑。 4.1 分支的基本行为模式作为全局事务一部分的分支事务，除本身的业务逻辑外，都包含 4 个与协调器交互的行为： 分支注册： 在分支事务的数据操作进行之前，需要向协调器注册，把即将进行的分支事务数据操作，纳入一个已经开启的全局事务的管理中去，在分支注册成功后，才可以进行数据操作。 状态上报： 在分支事务的数据操作完成后，需要向事务协调器上报其执行结果。 分支提交：响应协调器发出的分支事务提交的请求，完成分支提交。 分支回滚：响应协调器发出的分支事务回滚的请求，完成分支回滚。 4.2 AT 模式分支的行为模式业务逻辑不需要关注事务机制，分支与全局事务的交互过程自动进行。 4.3 MT 模式分支的行为模式业务逻辑需要被分解为 Prepare/Commit/Rollback 3 部分，形成一个 MT 分支，加入全局事务。 MT 模式一方面是 AT 模式的补充。另外，更重要的价值在于，通过 MT 模式可以把众多非事务性资源纳入全局事务的管理中。 4.4 混合模式因为 AT 和 MT 模式的分支从根本上行为模式是一致的，所以可以完全兼容，即，一个全局事务中，可以同时存在 AT 和 MT 的分支。这样就可以达到全面覆盖业务场景的目的：AT 模式可以支持的，使用 AT 模式；AT 模式暂时支持不了的，用 MT 模式来替代。另外，自然的，MT 模式管理的非事务性资源也可以和支持事务的关系型数据库资源一起，纳入同一个分布式事务的管理中。 4.5 应用场景的远景回到我们设计的初衷：一个理想的分布式事务解决方案是不应该侵入业务的。MT 模式是在 AT 模式暂时不能完全覆盖所有场景的情况下，一个比较自然的补充方案。我们希望通过 AT 模式的不断演进增强，逐步扩大所支持的场景，MT 模式逐步收敛。未来，我们会纳入对 XA 的原生支持，用 XA 这种无侵入的方式来覆盖 AT 模式无法触达的场景。 5. 扩展点5.1 微服务框架的支持事务上下文在微服务间的传播需要根据微服务框架本身的机制，订制最优的，对应用层透明的解决方案。有兴趣在这方面共建的开发者可以参考内置的对 Dubbo 的支持方案，来实现对其他微服务框架的支持。 5.2 所支持的数据库类型因为 AT 涉及 SQL 的解析，所以在不同类型的数据库上工作，会有一些特定的适配。有兴趣在这方面共建的开发者可以参考内置的对 MySQL 的支持方案，来实现对其他数据库的支持。 5.3 配置和服务注册发现支持接入不同的配置和服务注册发现解决方案。比如：Nacos、Eureka、ZooKeeper 等。 5.4 MT 模式的场景拓展MT 模式的一个重要作用就是，可以把非关系型数据库的资源，通过 MT 模式分支的包装，纳入到全局事务的管辖中来。比如，Redis、HBase、RocketMQ 的事务消息等。有兴趣在这方面共建的开发者可以在这里贡献一系列相关生态的适配方案。 5.5 事务协调器的分布式高可用方案针对不同场景，支持不同的方式作为事务协调器 Server 端的高可用方案。比如，针对事务状态的持久化，可以是基于文件的实现方案，也可以是基于数据库的实现方案；集群间的状态同步，可以是基于 RPC 通信的方案，也可以是基于高可用 KV 存储的方案。 6. Roadmap蓝图 绿色 部分是已经开源发布出来的，黄色 部分是将在后续版本中由阿里发布出来的，蓝色 部分是我们和社区共建生态部分： 对不同数据库的支持，开发者可以参考 MySQL 的实现。 对不同微服务框架的支持，开发者可以参考 Dubbo 的实现。 对 MQ、NoSQL 的支持，开发者可以参考 TCC 的实现。 配置和服务注册发现：开发者通过少量的工作可以接入任何可以提供这类服务的框架。 当然，非 蓝色 的部分也非常欢迎社区参与进来，贡献更优的解决方案。 另外，XA 作为分布式事务的标准，是一个完备的分布式事务解决方案不可或缺的，远景的规划中，我们一定需要把 XA 的支持加入进来。 初步的版本规划v0.1.0 微服务框架支持: Dubbo 数据库支持: MySQL 基于 Spring AOP 的 Annotation 事务协调器: 单机版本 v0.5.x 微服务框架支持: Spring Cloud MT 模式 支持 TCC 模式事务的适配 动态配置和服务发现 事务协调器: 高可用集群版本 v0.8.x Metrics 控制台: 监控/部署/升级/扩缩容 v1.0.0 General Availability: 生产环境适用 v1.5.x 数据库支持: Oracle/PostgreSQL/OceanBase 不依赖 Spring AOP 的 Annotation 热点数据的优化处理机制 RocketMQ 事务消息纳入全局事务管理 NoSQL 纳入全局事务管理的适配机制 支持 HBase 支持 Redis v2.0.0 支持 XA 当然，项目迭代演进的过程，我们最重视的是社区的声音，路线图会和社区充分交流及时进行调整。 7. 相关链接 FESCAR on GitHub GTS on Aliyun]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>事务</tag>
        <tag>XA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之解释器模式]]></title>
    <url>%2F2019%2F01%2F10%2Fdesign-pattern-interpreter%2F</url>
    <content type="text"><![CDATA[解释器模式 是类的行为模式，给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。 意图 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决 对于一些固定文法构建一个解释句子的解释器。 何时使用 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决 构件语法树，定义终结符与非终结符。 关键代码 构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。 解释器模式相关UML图类图 可以看出右侧的协作图(object collaboration diagram)展现出运行时的解释器模式。Client向右侧抽象语法树发送解释请求，请求被转发并向下到树结构的所有对象。 解释器模式的主要角色 抽象解释器(AbstractExpression/Expression)：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。 终结符表达式(TerminalExpression)：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 非终结符表达式(NonterminalExpression)：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。 环境角色(Context)：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。 干货代码跳转到源码地址 简单的一个解释器计算加减乘除算法，环境上下文没有用好，其实计算规则更多的是人为设定的了。 本次的抽象接收器用的是抽象类，用接口代替也可以。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//抽象解释器public abstract class AbstractExpression &#123; public abstract int interpreter(Context context);&#125;//非终结表达式：加法@Data@AllArgsConstructorpublic class Add extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; return left.interpreter(context) + right.interpreter(context); &#125;&#125;//非终结表达式：减法@Data@AllArgsConstructorpublic class Subtract extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; return left.interpreter(context) - right.interpreter(context); &#125;&#125;//非终结表达式：乘法@Data@AllArgsConstructorpublic class Multiply extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; return left.interpreter(context) * right.interpreter(context); &#125;&#125;//非终结表达式：除法@Data@AllArgsConstructorpublic class Division extends AbstractExpression &#123; private final AbstractExpression left; private final AbstractExpression right; @Override public int interpreter(Context context) &#123; int right = this.right.interpreter(context); if (right != 0) &#123; return left.interpreter(context) / right; &#125; return -1; &#125;&#125;//终结表达式：变量@Data@AllArgsConstructorpublic class Variable extends AbstractExpression &#123; private final String key; @Override public int interpreter(Context context) &#123; return context.getValue(key); &#125;&#125;//环境上下文@Getterpublic class Context &#123; private final Map&lt;String, Integer&gt; valueMap = Maps.newHashMap(); public void addValue(final String key, final int value) &#123; valueMap.put(key, Integer.valueOf(value)); &#125; public int getValue(final String key) &#123; return valueMap.get(key).intValue(); &#125;&#125;//public class Application &#123; public static void main(String[] args) &#123; Context context = new Context(); context.addValue("a", 6); context.addValue("b", 9); context.addValue("c", 1); Variable a = new Variable("a"); Variable b = new Variable("b"); Variable c = new Variable("c"); AbstractExpression multiplyValue = new Multiply(a, b); AbstractExpression subtractValue = new Subtract(a, b); AbstractExpression addValue = new Add(subtractValue, c); AbstractExpression divisionValue = new Division(multiplyValue, addValue); log.info("&#123;&#125;", context.getValueMap()); log.info("(a*b)/(a-b+c) = &#123;&#125;", divisionValue.interpreter(context)); &#125;&#125; 结果如下： Java中的应用 java中的表达式引擎parsiiJEvalJEPLiteexprJaninoMathEval Java表达式引擎fel/groovy/expression4j/java脚本引擎的性能对比 JDK中的应用这个模式通常定义了一个语言的语法，然后解析相应语法的语句。 java.util.Pattern java.text.Normalizer java.text.Format 参考解释器模式|菜鸟教程 Interpreter pattern 细数JDK里的设计模式 23种设计模式（14）：解释器模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之访问者模式]]></title>
    <url>%2F2019%2F01%2F07%2Fdesign-pattern-visitor%2F</url>
    <content type="text"><![CDATA[访问者模式 Represent an operation to be performed on the elements of an object structure. Visitor lets a new operation be defined without changing the classes of the elements on which it operates. 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。 意图 主要将数据结构与数据操作分离。 主要解决 稳定的数据结构和易变的操作耦合问题。 何时使用 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 访问者模式的主要角色 Visitor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。 ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。 Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。 ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。 ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 访问者模式相关UML图UML类图和时序图 在类图中可以看出，ElementA实现了接口Element的accept(visitor)方法，而通过visitor.visitElementA(this)，相同visitor1类通过实现visitElementA(ElementA a)方法与ElementA关联。相同的ElementB亦是如此原理。 右上角的时序图，Client对象有一组Element的数据结构，通过循环对每个元素Element调用accept(visitor)方法，例如先是ElementA调用accept(visitor)，实际上就是调用visitor1的visitElementA(A)，同样情况对ElementB。 更加清晰的类图如下 实例干货跳转到对应的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//抽象元素public interface Element &#123; void accept(ElementVisitor visitor);&#125;//具体元素-车轮@Data@AllArgsConstructorpublic class Wheel implements Element &#123; private String name; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-车身public class Body implements Element &#123; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-引擎public class Engine implements Element &#123; @Override public void accept(ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//具体元素-整车public class Car implements Element &#123; public void accept(final ElementVisitor visitor) &#123; visitor.visit(this); &#125;&#125;//抽象访问者public interface ElementVisitor &#123; void visit(Body body); void visit(Engine engine); void visit(Wheel wheel); void visit(Car car);&#125;//具体的一个访问者，纯打印@Slf4jpublic class DoElementVisitor implements ElementVisitor &#123; @Override public void visit(Body body) &#123; log.info("Moving my body"); &#125; @Override public void visit(Engine engine) &#123; log.info("Starting my engine"); &#125; @Override public void visit(Wheel wheel) &#123; log.info("Kicking my " + wheel.getName() + " wheel"); &#125; @Override public void visit(Car car) &#123; log.info("Starting my car"); &#125;&#125;//单独还定义对象结构，其实完全就可以使用列表就可以@Datapublic class ElementStructure &#123; private List&lt;Element&gt; list = Lists.newArrayList(); public void addElement(Element element)&#123; list.add(element); &#125; public void accept(ElementVisitor visitor) &#123; for (Element elem : list) &#123; elem.accept(visitor); &#125; &#125;&#125; 上述就是针对访问者模式做的一个对于汽车零件的一个打印效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ClientWithVisitor &#123; public static void main(String[] args) &#123; ElementStructure structure = new ElementStructure(); structure.addElement(new Wheel("front left")); structure.addElement(new Wheel("front right")); structure.addElement(new Wheel("back left")); structure.addElement(new Wheel("back right")); structure.addElement(new Body()); structure.addElement(new Engine()); structure.addElement(new Car()); structure.accept(new DoElementVisitor()); &#125;&#125;@Slf4jpublic class ClientWithoutVisitor &#123; public static void main(String[] args) &#123; ElementStructure structure = new ElementStructure(); structure.addElement(new Wheel("front left")); structure.addElement(new Wheel("front right")); structure.addElement(new Wheel("back left")); structure.addElement(new Wheel("back right")); structure.addElement(new Body()); structure.addElement(new Engine()); structure.addElement(new Car()); structure.getList().forEach(e -&gt; &#123; if (e instanceof Body) &#123; log.info("Moving my body"); &#125; else if (e instanceof Engine) &#123; log.info("Starting my engine"); &#125; else if (e instanceof Car) &#123; log.info("Starting my car"); &#125; else if (e instanceof Wheel) &#123; log.info("Kicking my " + ((Wheel)e).getName() + " wheel"); &#125; &#125;); &#125;&#125; 打印结果都是一样的 总结分析在上面的例子中分别用了访问者模式和非访问者模式两种方法。 1、使用VIsitor的好处一目了然，当需要修改某些元素的业务逻辑时，只需要修改Visitor类中相对应的操作函数即可。例如假设要修改Wheel的逻辑，只需要修改Visitor的visit(Wheel wheel)方法即可。 2、假设我们又需要新增一个汽车元素天窗的话，只需要在visitor中添加新的接口以处理新元素，而别的元素可以保持不动。 违背开闭原则。 3、当我们需要添加新的业务操作，只需要添加新的具体访问者，其他的依旧可以保持不变。符合开闭原则。 同样，有好处也就有缺陷，因为逻辑在visitor里面，所有visitor和Element高度耦合，同样针对visit方法返回类型，需要设计的优雅，如若不然，后期一旦修改返回类型，影响的范围就广，所有访问者接口和实现都波及到。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问，这一点跟迪米特法则和依赖倒置原则相违背。 总的而言，访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。 JDK中含有的访问者模式提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。 javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor 参考访问者模式|菜鸟教程 Visitor pattern JAVA设计模式（23）：行为型-访问者模式（Visitor）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计模式原则]]></title>
    <url>%2F2019%2F01%2F05%2Fprinciples-of-software-design-patterns%2F</url>
    <content type="text"><![CDATA[软件设计模式原则在我们面向对象的设计过程中，我们的code既要可读性高方便维护，同时还需要另外一个可复用性。这次我们来学习软件设计模式中涉及到的一些原则————&gt;面向对象设计 SOLID 这就是吐槽： 但是我们往往接手的项目，都是苦不堪言，一把鼻涕一把泪，看前人留下的杰作，那是相当痛苦，千万匹MMP奔腾，填坑，还技术债。 入正题，在有些说七大原则，有些说六大原则，有些说五大原则，但是最重要的就是SOLID了。 国内的博文大部分都说七大和六大原则，Google下solid，看老外的文章和wiki都是五大原则。 我们先看SOLID，是罗伯特·C·马丁搞出来的首字母缩写记忆，这个Bob大叔。 Single Responsibility Principle：单一职责原则，解释：一个类只负责一个功能领域中的相应职责 Open Closed Principle：开闭原则，解释：软件实体应对扩展开放，而对修改关闭 Liskov Substitution Principle：里氏替换原则，解释：所有引用基类对象的地方能够透明地使用其子类的对象 Interface Segregation Principle：接口隔离原则，解释：使用多个专门的接口，而不使用单一的总接口 Dependence Inversion Principle：依赖倒置原则，解释：抽象不应该依赖于细节，细节应该依赖于抽象 剩下的两大原则 Composite Reuse Principle 合成复用原则，解释：尽量使用对象组合，而不是继承来达到复用的目的 Law of Demeter 迪米特法则，解释：一个软件实体应当尽可能少地与其他实体发生相互作用 单一职责原则 a class should have only a single responsibility (i.e. only changes to one part of the software’s specification should be able to affect the specification of the class). 顾名思义，就是一个类只负责一个职责。不能有多个导致类变更的原因。 让类的职责单一，只需要负责自己部分，复杂度就会降低，代码维护起来也更加容易。原则不仅仅适用于类，对于接口和方法也适用，即一个接口/方法，只负责一件事，这样的话，接口就会变得简单，方法中的代码也会更少，易读，便于维护。事实上，由于一些其他的因素影响，类的单一职责在项目中是很难保证的。通常，接口和方法的单一职责更容易实现。 好处： 代码的粒度降低了，类的复杂度降低了。 可读性提高了，每个类的职责都很明确，可读性自然更好。 可维护性提高了，可读性提高了，一旦出现 bug ，自然更容易找到他问题所在。 改动代码所消耗的资源降低了，更改的风险也降低了。 高内聚、低耦合 假设有一类C，含有logging、order、pay3个方法，实则就这个类就不是单一指责了，按要求后我们保留单一指责order方法。后期需求来了，我们要对order方法进行修改，产生了order1和order2，尽量在方法级别保留了单一指责，或者这个时候修改为类C1和C2，都有order方法。这两种方法，我们往往选择前者较多，但是有些2者都不选择，直接就在类C中order方法进行修改，支持多种需求，在这一步就违法单一指责。需求有可能在未来导致order方法扩散到n个。记住，在指责扩散到无法控制时，一定要重构。 开闭原则 software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. 软件实体如类、模块、方法等对于扩展开放的，但是对于修改封闭的。 我们试想一下，产品来需求了，对我们原有的代码要进行升级或者改变的时候，可能我们在修改旧的业务代码时，往往也会新增新的bug，这个时候，有可能因为功能复杂情况下要对整个功能进行重构。这个时候，就应该想到开闭原则，通过扩展实现改变而不是修改原有的东西。 有没有感觉，对扩展开放，对修改关闭。说起来很简单，感觉像啥也没说一样，具体起来该如何做。 Open–closed principle中一文有描述，通过继承抽象类和实现接口。 其实，这也正是我们面向对象中的框架设计—–抽象，用抽象构建框架，用实现扩展细节。我们队框架进行关闭，通过实现细节进行开放。而我们的业务常常就是这些细节，通过细节的实现，我们就能完成扩展。但是前提是我们的框架要足够抽象化，具有针对需求的满足性，要有足够的预埋性，这其实也是需要一定的经验。 里氏替换原则 objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. 程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。简单点，就是我用基类代替子类的话，程序还是一样的，是对的。 Liskov substitution principle有讲明里氏替换原则的来路。Barbara Liskov女士提出来的。 PDF中有相关的介绍 是这么定义的： 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 通俗点理解： 例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在使用里氏代换原则时需要注意如下几个问题： (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 12345678910111213class A&#123; public int func1(int a, int b)&#123; return a-b; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); System.out.println("100-50="+a.func1(100, 50)); System.out.println("100-80="+a.func1(100, 80)); &#125;&#125; 运行结果： 100-50=50 100-80=20 123456789101112131415161718class B extends A&#123; public int func1(int a, int b)&#123; return a+b; &#125; public int func2(int a, int b)&#123; return func1(a,b)+100; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; B b = new B(); System.out.println("100-50="+b.func1(100, 50)); System.out.println("100-80="+b.func1(100, 80)); System.out.println("100+20+100="+b.func2(100, 20)); &#125;&#125; 类B完成后，运行结果： 100-50=150 100-80=180 100+20+100=220 通过这个举例可以看出子类改变了父类原有的功能，子类无意或者有意重写了父类的方法。导致本来的减法变成了加法。 接口隔离原则 many client-specific interfaces are better than one general-purpose interface. 多个特定客户端接口要好于一个宽泛用途的接口。 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。将一个庞大的接口变更为多个专用的接口所采用的就是接口隔离原则。 例如：接口I有5个方法M1,M2,M3,M4,M5，假设现在有3个实现类C1实现5分方法，实现类C2只实现前面3个方法M1,M2,M3其他2个则是空实现，实现类C3只实现M4,M5其他3个则是空实现。这个时候就体现出接口庞大了。此时应将接口I拆分成接口I1有方法M1,M2,M3，接口I2有方法M4,M5。而实现类C1实现接口I1和I2，实现类C2实现接口I1，实现类C3实现接口I2。 接口隔离原则跟单一职责原则很相似。其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 依赖倒置原则 one should “depend upon abstractions, [not] concretions. 依赖于抽象而不是一个实例。其实想想依赖注入是该原则的一种实现方式。 The principle states: High-level modules should not depend on low-level modules. Both should depend on abstractions). Abstractions should not depend on details. Details should depend on abstractions. 翻译过来是：高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节。细节应该依赖抽象。 在Java语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。接口或抽象类不依赖于实现类。实现类依赖于接口或抽象类。 简而言之，尽可能的使用接口或者抽象类，即所谓的面向接口编程。 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 这张图，其实就很好的表达了依赖倒置原则，ObjectB应该依赖InterfaceA去申明ObjectA而非直接去依赖ObjectA，而ObjectA也应该依赖InterfaceA，这就是高层模块不应该依赖底层模块，两者都应该依赖其抽象和细节应该依赖抽象。 我们来看看如下的示例，刚开始，学生只是简单的完成学校里的白天课堂作业。 12345678910111213141516public class SchoolWork &#123; public void work() &#123; System.out.println("学生每天在学校就完成课堂作业了"); &#125;&#125;public class Student &#123; public void work(SchoolWork schoolWork) &#123; schoolWork.work(); &#125;&#125;//客户端调用Student student = new Student();SchoolWork work = new SchoolWork();student.work(work); 我们发现，学生每天都在课堂上就完成了作业，但是随着时间慢慢的过去，学生们，课堂作业变多了，老师开始布置家庭作业了。那么Student类中再写一个写家庭作业的方法嘛，万一老师又给学生布置其他作业又写一种方法吗，肯定不是的啦。 这个时候就需要把作业抽象起来了，用接口或者抽象类都可以。 12345678910111213141516171819202122232425262728public interface Work &#123; public void work();&#125;public class SchoolWork implements Work &#123; public void work() &#123; System.out.println("学生每天在学校就完成课堂作业了"); &#125;&#125;public class HomeWork implements Work &#123; public void work() &#123; System.out.println("学生每天在家就完成家庭作业了"); &#125;&#125;public class Student &#123; public void work(Work work) &#123; work.work(); &#125;&#125;//客户端调用Student student = new Student();Work work = new SchoolWork();student.work(work);work = new HomeWork();student.work(work); 这就是面向接口编程。Work work = new SchoolWork();和work = new HomeWork();就是变量的声明类型尽量是抽象类或者接口。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 迪米特法则From Wikipedia, the free encyclopedia Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.Each unit should only talk to its friends; don’t talk to strangers.Only talk to your immediate friends. 每个单位对其他单位的了解应该是有限，除了跟自己相对密切的单位。的不要和陌生人说话啊，只与直接的朋友通信。 看完之后，是不是云里雾里，不知道说什么鸟语花香。其实就是，一个对象应该对其他对象保持最少的了解。啊，你还是不知道它说了个啥。通俗的讲就是一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类，向外公开的方法应该尽可能的少(尽可能的不用用public修饰方法)。对于上面的朋友的定义来讲，两个对象之间的耦合关系称之为朋友，通常有依赖、关联、聚合和组成等。而直接朋友则通常表现为关联、聚合和组成关系，即两个对象之间联系更为紧密，通常以成员变量、方法的参数和返回值的形式出现。同时了陌生的类最好不要作为局部变量的形式出现在类的内部。 朋友了也是有这样几种定义的 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象，如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。 来看个示例，关计算机的业务。 主要是针对只暴露应该暴露的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//计算机类public class Computer&#123; public void saveCurrentTask()&#123; //do something &#125; public void closeService()&#123; //do something &#125; public void closeScreen()&#123; //do something &#125; public void closePower()&#123; //do something &#125; public void close()&#123; saveCurrentTask(); closeService(); closeScreen(); closePower(); &#125;&#125;//人public class Person&#123; private Computer c; ... public void clickCloseButton()&#123; //现在你要开始关闭计算机了，正常来说你只需要调用close（）方法即可， //但是你发现Computer所有的方法都是公开的，该怎么关闭呢？于是你写下了以下关闭的流程： c.saveCurrentTask(); c.closePower(); c.close(); //亦或是以下的操作 c.closePower(); //还可能是以下的操作 c.close(); c.closePower(); &#125;&#125; 从被依赖者的角度，只应该暴露应该暴露的方法。那么这里的c对象应该哪些方法应该是被暴露的呢？很显然，对于Person来说，只需要关注计算机的关闭操作，而不关心计算机会如何处理这个关闭操作，因此只需要暴露close（）方法即可。 1234567891011121314151617181920212223242526272829303132333435//计算机类public class Computer&#123; private void saveCurrentTask()&#123; //do something &#125; private void closeService()&#123; //do something &#125; private void closeScreen()&#123; //do something &#125; private void closePower()&#123; //do something &#125; public void close()&#123; saveCurrentTask(); closeService(); closeScreen(); closePower(); &#125;&#125;//人public class Person&#123; private Computer c; ... public void clickCloseButton()&#123; c.close(); &#125;&#125; 再来看一个示例，只依赖应该依赖的对象 123456789101112131415161718192021222324252627282930313233343536373839public class A &#123; public D do(B b) &#123; C c = b.getC().; c.doSomething(); D d = c.getResult() return d; &#125;&#125;@Datapublic class B &#123; private C c;&#125;@Datapublic class C &#123; public void doSomething() &#123; //..... &#125; public D getResult() &#123; //..... return new D(); &#125;&#125;@Datapublic class D &#123; //.......&#125;public class Client &#123; public void main(String[] args) &#123; A a = new A(); B b = new B(); System.out.println(a.do(b)); &#125;&#125; 从上述例子中，可以看出，在A类的do方法中，类C其实相对于类A来说就是陌生人，高耦合在A类中。假设日后，我们对C类的doSomething和getResult方法改动时，就会影响到类A。 至于如何修改，想看看看官们有什么建议或者实现，欢迎留言。 总的来说，在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。高内聚，低耦合。 合成复用原则也称为合成/聚合复用原则，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 其原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。 如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 聚合（Aggregation）表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象但B对象不是A对象的一部分。如上图中的大雁属于雁群的，一个雁群是有很多大雁。聚合关系用空心的菱形+实线来表示。 合成（Composition）则是一种强的’拥有’关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。例如上图大雁人是有头、翅膀等合成的，大雁和头、翅膀的生命周期是一样的，大家一起玩完。合成关系用实心的菱形+实线来表示。 通常类的复用分为继承复用和合成复用 两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 总结单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 参考SOLID Design Principles Explained The SOLID Principles in Real Life S.O.L.I.D: The First 5 Principles of Object Oriented Design SOLID 设计模式六大原则——SOLID 软件设计模式六大原则 浅谈 SOLID 原则的具体使用 白话设计——浅谈迪米特法则 合成复用原则——面向对象设计原则]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之迭代器模式]]></title>
    <url>%2F2019%2F01%2F02%2Fdesign-pattern-iterator%2F</url>
    <content type="text"><![CDATA[迭代器模式 Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 提供一种不公示其底层细节(结构)的情况下能顺序访问聚合对象元素的方法。其实在java体系中，jdk已经引入了迭代器接口以及对于的容器接口等。就拿迭代器中的角色，在java中找出其对应的类。 具体角色 (1)迭代器角色(Iterator)：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法next()，判断是否遍历结束的方法hasNext()），移出当前对象的方法remove(), (2)具体迭代器角色(Concrete Iterator)：实现迭代器接口中定义的方法，完成集合的迭代。 (3)容器角色(Aggregate): 一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等 (4)具体容器角色(ConcreteAggregate)：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。 单独举出ArrayList的角色， 迭代器角色对应java中的java.lang.Iterator，这个迭代器是java容器公用的。 容器角色对应java.lang.Iterable，其还有Iterator iterator()方法获取迭代器。 具体迭代器角色对应java.lang.ArrayList.Itr，实现了对应的hasNext、next、remove方法。 具体容器角色那就是java.lang.ArrayList了，实现iterator方法返回Itr具体迭代器，用游标形式实现。 再看看UML类 项目实例源码在Github 项目中很简单的实现了一个容器和迭代器。大致参考了ArrayList实现，但是是简洁版本，去除很多无关以及性能上的东西，只保留最基本的迭代器元素。 12345678910111213141516@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Aggregate&lt;Integer&gt; aggregate = new ConcreteAggregate&lt;&gt;(); aggregate.add(1); aggregate.add(2); aggregate.add(3); aggregate.add(4); Iterator&lt;Integer&gt; iterator = aggregate.iterator(); while (iterator.hasNext()) &#123; log.info("循环数据&#123;&#125;", iterator.next()); &#125; &#125;&#125; 执行结果如下 简单的迭代器定义 1234567public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next();&#125; 简单容器定义 1234567public interface Aggregate&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); void add(T t);&#125; 具体容器和具体的迭代器定义 123456789101112131415161718192021222324252627282930313233343536373839404142public class ConcreteAggregate&lt;E&gt; implements Aggregate&lt;E&gt; &#123; private Object[] elements; private int size = 0; public ConcreteAggregate() &#123; elements = new Object[16]; &#125; public int getSize() &#123; return size; &#125; public void add(E e) &#123; elements[size++] = e; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ConcreteIterator&lt;E&gt;(); &#125; private class ConcreteIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; int cursor; @Override public boolean hasNext() &#123; return cursor != size; &#125; @Override public E next() &#123; if (cursor &gt;= size) &#123; return null; &#125; return (E) elements[cursor++]; &#125; &#125;&#125; 具体容器中用数组来作为容器来存储元素，而且最简单的容器，固定了大小，并没有实现扩容的算法等等，只是一个简单的样例，但是大部分上，都是直接使用java带有的迭代器。 优点 简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。 可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。 封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。 缺点由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。 总结迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。 参考wiki的迭代器模式 迭代器模式|菜鸟教程 Java设计模式系列之迭代器模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之命令模式]]></title>
    <url>%2F2019%2F01%2F02%2Fdesign-pattern-command%2F</url>
    <content type="text"><![CDATA[命令模式 wiki上的描述 Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests, and the queuing or logging of requests. It also allows for the support of undoable operations. 翻译意思，把请求封装成一个对象，从而允许我们可以对客户端的不同请求进行参数化，以及对请求进行排队或记录。还允许支持撤销操作。看起来好像很复杂，很难理解。 通俗简单理解，它就是将请求封装成一个对象，在这里就是这个对象就是命令，而这个命令就是将请求方和执行方分离隔开。从而每一个命令其实就是操作，而这样的流程就是请求方发出请求要求执行某操作，接收方收到请求后并执行对应的操作。这样下来，请求方和接收方就解耦了，使得请求方完全不知道接受的操作方法，从也不会知道接收方是何时接受到请求的，又是何时执行操作的，又是怎么执行操作的。 具体的角色 Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。 ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。 Invoker（请求方）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。 Receiver（接收方）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。 Client（客户端）：创建具体命令的对象并且设置命令对象的接受者。 再来看看UML图 从上方的时序图中可以看出运行的顺序，Invoker执行execute方法，调用Command1对象，Command1执行action1方法调用Receiver1对象。 干货代码源码在我的GitHub地址 普通的命令模式现在结合下上回说到的状态模式一起来实现这个风扇的左转和右转功能，这次把他用命令模式来代替之前风扇的转动，把它当做命令来。 客户端简单的定义请求方和接收方以及对于的左转命令和右转命令，设置命令后对应的执行命令。 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.setCommand(leftCommand); invoker.execute(); invoker.execute(); &#125;&#125; 请求方 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125;&#125; 抽象命令 1234public interface Command &#123; void execute();&#125; 开关左转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125;&#125; 开关右转 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 通过命令模式把左转和右转封装成命令，以及之前的状态模式变更风扇的状态。本次就是通过状态模式和命令模式实现了一个风扇开关左右转的功能。 宏命令或者叫做组合命令设计一组命令，简单的处理事情，打印一句话，封装成一组命令。这次我们用了Java8来写，可以使用lambda。 12345678910111213141516171819202122232425262728@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); log.info("初始化ABC3个命令"); Command aCommand = () -&gt; log.info("A处理这个请求"); invoker.addCommand(aCommand); invoker.addCommand(() -&gt; log.info("B处理这个请求")); invoker.addCommand(() -&gt; log.info("C处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令D"); invoker.addCommand(() -&gt; log.info("D处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("加入新命令E"); invoker.addCommand(() -&gt; log.info("E处理这个请求")); invoker.execute(); log.info("---------------------------"); log.info("移除命令A"); invoker.removeCommand(aCommand); invoker.execute(); &#125;&#125; 打印语句。 抽象命令 12345@FunctionalInterfacepublic interface Command &#123; void execute();&#125; 请求方 1234567891011121314151617181920212223@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private List&lt;Command&gt; commandList = Lists.newArrayList(); public void addCommand(Command command) &#123; commandList.add(command); &#125; public void removeCommand(Command command) &#123; commandList.remove(command); &#125; public void execute() &#123; if(CollectionUtils.isEmpty(commandList)) &#123; return; &#125; commandList.stream().forEach(command -&gt; command.execute()); &#125;&#125; 撤销操作在普通的命令模式的基础上，增加了撤销操作，在这里的撤销操作，其实即为左转时的右转，右转时的左转。 123456789101112131415161718192021@Slf4jpublic class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command leftCommand = new LeftCommand(receiver); Command rightCommand = new RightCommand(receiver); invoker.setCommand(rightCommand); invoker.execute(); invoker.execute(); invoker.execute(); invoker.undo(); invoker.undo(); invoker.setCommand(leftCommand); invoker.execute(); invoker.undo(); &#125;&#125; 抽象命令增加了撤销操作 123456public interface Command &#123; void execute(); void undo();&#125; 具体左转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class LeftCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.left(); &#125; @Override public void undo() &#123; receiver.right(); &#125;&#125; 右转时 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class RightCommand implements Command &#123; private Receiver receiver; @Override public void execute() &#123; receiver.right(); &#125; @Override public void undo() &#123; receiver.left(); &#125;&#125; 请求方 12345678910111213141516@Data@AllArgsConstructor@NoArgsConstructorpublic class Invoker &#123; private Command command; public void execute() &#123; command.execute(); &#125; public void undo() &#123; command.undo(); &#125;&#125; 接收方 123456789101112public class Receiver &#123; private Context context = new Context(new CloseLevelState()); public void left() &#123; context.left(); &#125; public void right() &#123; context.right(); &#125;&#125; 命令模式总结优点 (1) 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 (2) 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 (3) 可以比较容易地设计一个命令队列或宏命令（组合命令）。 (4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。 适用场景 (1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 (2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 (3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 (4) 系统需要将一组操作组合在一起形成宏命令。 (5)线程池有一个addTash方法，将任务添加到待完成的队列中，队列中的元素就是命令对象，通常的就是一个公共接口，像我们常用的java.lang.Runnable接口。 (6)java8之后，最好在Command接口中@FunctionalInterface修饰，这样具体的命令就可以使用lambda表达式啦。 Java中的使用将操作封装到对象内，以便存储，传递和返回。 java.lang.Runnable javax.swing.Action 文章参考java设计模式之命令模式 细数JDK里的设计模式 wiki的命令模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之状态模式]]></title>
    <url>%2F2018%2F12%2F24%2Fdesign-pattern-state%2F</url>
    <content type="text"><![CDATA[状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。通俗点就是一个对象在内部状态发生改变时改变它的行为。 介绍意图 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用 代码中包含大量与对象状态有关的条件语句。 如何解决 将各种具体的状态类抽象出来。 关键代码 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 UML图 主要角色 1）Context(环境类)：环境类拥有各种不同状态的对象，作为外部使用的接口，负责调用状态类接口。 2）State(抽象状态)：抽象状态既可以为抽象类，也可以直接定义成接口。主要用于定义状态抽象方法，具体实现由子类负责。 3）ConcreteState(具体状态类):具体状态类为抽象状态的实现者，不同的状态类对应这不同的状态，其内部实现也不相同。环境类中使用不同状态的对象时，能实现不同的处理逻辑 应用实例 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景 行为随状态改变而改变的场景。 条件、分支语句的代替者。 状态模式和策略模式的对比现在我们知道，状态模式和策略模式的结构是相似的，但它们的意图不同。让我们重温一下它们的主要不同之处： 策略模式封装了一组相关算法，它允许Client在运行时使用可互换的行为；状态模式帮助一个类在不同的状态显示不同的行为。 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而通过从Context中分离出策略或算法，我们可以重用它们。 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。 策略实现可以作为参数传递给使用它的对象，例如Collections.sort()，它的参数包含一个Comparator策略。另一方面，状态是Context对象自己的一部分，随着时间的推移，Context对象从一个状态转移到另一个状态。 虽然它们都符合OCP原则，策略模式也符合SRP原则（单一职责原则），因为每个策略都封装自己的算法，且不依赖其他策略。一个策略的改变，并不会导致其他策略的变化。 另一个理论上的不同：策略模式定义了对象“怎么做”的部分。例如，排序对象怎么对数据排序。状态模式定义了对象“是什么”和“什么时候做”的部分。例如，对象处于什么状态，什么时候处在某个特定的状态。 状态模式中很好的定义了状态转移的次序；而策略模式并无此需要：Client可以自由的选择任何策略。 一些常见的策略模式的例子是封装算法，例如排序算法，加密算法或者压缩算法。如果你看到你的代码需要使用不同类型的相关算法，那么考虑使用策略模式吧。而识别何时使用状态模式是很简单的：如果你需要管理状态和状态转移，但不想使用大量嵌套的条件语句，那么就是它了。 最后但最重要的一个不同之处是，策略的改变由Client完成；而状态的改变，由Context或状态自己。 项目实例跳转到我的源码地址 simple1包中主要是对风扇的开关状态进行转换，其实我们是把状态放在状态类中进行按照固定的逻辑转换，但是这种模式其实他不符合开闭原则，为什么了，因为一旦我们发生新增、修改或者删除状态的时候，就需要修改状态类中的状态转换。 123456789101112public class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new CloseLevelState()); context.right(); context.right(); context.right(); context.left(); context.right(); context.right(); &#125;&#125; 抽象状态 12345678910111213141516171819202122public interface LevelState &#123; /** * 左转 * * @param context */ void left(Context context); /** * 右转 * * @param context */ void right(Context context); /** * 当前档位 * @return */ String info();&#125; 具体档位状态，我只列了2个，其他的类似 12345678910111213141516171819202122@Slf4jpublic class OneLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new CloseLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new TwoLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "1档"; &#125;&#125; 1234567891011121314151617181920212223@Slf4jpublic class CloseLevelState implements LevelState &#123; @Override public void left(Context context) &#123; LevelState levelState = new ForeLevelState(); context.setLevelState(levelState); log.info("风扇左转到&#123;&#125;", levelState.info()); &#125; @Override public void right(Context context) &#123; LevelState levelState = new OneLevelState(); context.setLevelState(levelState); log.info("风扇右转到&#123;&#125;", levelState.info()); &#125; @Override public String info() &#123; return "0档"; &#125;&#125; 真正的开关也就是上下文 123456789101112131415161718@Data@AllArgsConstructorpublic class Context &#123; private LevelState levelState; public void left() &#123; levelState.left(this); &#125; public void right() &#123; levelState.right(this); &#125; public String info() &#123; return levelState.info(); &#125;&#125; 参考Java中，状态模式和策略模式的区别 状态模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之责任链模式]]></title>
    <url>%2F2018%2F12%2F21%2Fdesign-pattern-chain%2F</url>
    <content type="text"><![CDATA[责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 简介意图 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用 在处理消息的时候以过滤很多道。 如何解决 拦截的类都实现统一接口。 关键代码 Handler 里面聚合它自己，在 handleRequest 里判断是否合适，如果没达到条件则向下传递。 纯责任链与不纯责任链 纯：纯责任链中的节点只有两种行为，一处理责任，二将责任传递到下一个节点。不允许出现某一个节点处理部分或全部责任后又将责任向下传递的情况。 不纯：允许某个请求被一个节点处理部分责任后再向下传递，或者处理完后其后续节点可以继续处理该责任，而且一个责任可以最终不被任何节点所处理。 主要角色 Handler（抽象处理者）： 定义一个处理请求的接口，提供对后续处理者的引用 ConcreteHandler（具体处理者）： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发 应用实例 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 Github项目描述跳转到我的责任链设计模式源码 1.出行方式travel包里主要对出行方式的责任链模式。跟进用户身上的钱，在优先级如飞机-&gt;火车-&gt;大巴的顺序下选择对应的出行模式。 123456789101112131415public class Application &#123; public static void main(String[] args) &#123; Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); planeHandler.setNext(trainHandler); trainHandler.setNext(busHandler); planeHandler.handleRequest("老王", 40d); planeHandler.handleRequest("张三", 140d); planeHandler.handleRequest("李四", 240d); planeHandler.handleRequest("吴老五", 340d); &#125;&#125; 抽象处理 12345678910@Datapublic abstract class Handler &#123; /** * 下一个链节点 */ protected Handler next; public abstract void handleRequest(String name, Double wallet);&#125; 具体的处理者（飞机、火车、大巴） 123456789101112131415161718@Slf4jpublic class PlaneHandler extends Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class TrainHandler extends Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 123456789101112131415161718@Slf4jpublic class BusHandler extends Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); return; &#125; if (Objects.nonNull(next)) &#123; next.handleRequest(name, wallet); return; &#125; log.info("&#123;&#125;钱不够，只能徒步啦", name); &#125;&#125; 2.出行方式2，参考Filter链的写法travel2包是对travel包的重新写法。 1234567891011121314151617public class Application &#123; public static void main(String[] args) &#123; HandlerChain chain = new HandlerChain(); Handler planeHandler = new PlaneHandler(); Handler trainHandler = new TrainHandler(); Handler busHandler = new BusHandler(); chain.addHandler(planeHandler); chain.addHandler(trainHandler); chain.addHandler(busHandler); chain.handle("老王", 40d); chain.handle("张三", 140d); chain.handle("李四", 240d); chain.handle("吴老五", 340d); &#125;&#125; 抽象处理者 1234public interface Handler &#123; void handleRequest(String name, Double wallet, HandlerChain chain);&#125; 具体处理者（飞机、火车、大巴） 123456789101112131415@Slf4jpublic class PlaneHandler implements Handler &#123; private double price = 280d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱可以坐飞机。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class TrainHandler implements Handler &#123; private double price = 149.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐火车。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 123456789101112131415@Slf4jpublic class BusHandler implements Handler &#123; private double price = 59.99d; @Override public void handleRequest(String name, Double wallet, HandlerChain chain) &#123; if (price &lt;= wallet) &#123; log.info("&#123;&#125;身上的钱只能坐大巴。", name); chain.reuse(); return; &#125; chain.handle(name, wallet); &#125;&#125; 责任链管理者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Slf4jpublic class HandlerChain &#123; private List&lt;Handler&gt; handlerList = new ArrayList&lt;&gt;(); /** * 维护当前链上位置 */ private int pos; /** * 链的长度 */ private int handlerLength; public void addHandler(Handler handler) &#123; handlerList.add(handler); handlerLength = handlerList.size(); &#125; public void handle(String name, double wallet) &#123; if (CollectionUtils.isEmpty(handlerList)) &#123; log.error("有钱，但没提供服务，&#123;&#125;也估计就只能步行了。", name); return; &#125; if (pos &gt;= handlerLength) &#123; log.error("身上钱不够，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; Handler handler = handlerList.get(pos++); if (Objects.isNull(handler)) &#123; log.error("假服务，&#123;&#125;也估计就只能步行了。", name); reuse(); return; &#125; handler.handleRequest(name, wallet, this); &#125; /** * 链重新使用 */ public void reuse() &#123; pos = 0; &#125;&#125; 学习Web项目的Filter待补充… 补充补充遗留的Filter过滤器中的责任链处理。 本次主要是对Tomcat中的Filter处理简单的梳理，如有不正确的地方，还望指出来，大家互勉，共进。 老项目大家可以在web.xml中配置filter，现使用Springboot后，也有两种配置filter方式，通过创建FilterRegistrationBean的方式和通过注解@WebFilter+@ServletComponentScan的方式。 三个主要的角色 FIlter，不多介绍了。 FilterChain servlet容器提供的开发调用链的过滤请求的资源。通过调用下一个filter实现过滤，在整体链上。 FilterConfig filter的配置器，在servlet容器在Filter初始化的时候传递信息。 具体的filter，主要说说Spring中的两个抽象Filter，GenericFilterBean和OncePerRequestFilter。 前者主要是做init和destroy的操作，重点还是init方法，destroy只是空实现而已。 后者主要是做真正的doFilter操作，也是我们在Spring中创建Filter通常继承的。 而ApplicationFilterChain就算Tomcat中的FilterChain实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 /** * The int which is used to maintain the current position * in the filter chain. */ private int pos = 0; /** * The int which gives the current number of filters in the chain. */ private int n = 0;@Overridepublic void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //安全相关的，暂不关注 if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; try &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123; @Override public Void run() throws ServletException, IOException &#123; internalDoFilter(req,res); return null; &#125; &#125; ); &#125; catch( PrivilegedActionException pe) &#123; Exception e = pe.getException(); if (e instanceof ServletException) throw (ServletException) e; else if (e instanceof IOException) throw (IOException) e; else if (e instanceof RuntimeException) throw (RuntimeException) e; else throw new ServletException(e.getMessage(), e); &#125; &#125; else &#123; //真正的doFilter internalDoFilter(request,response); &#125;&#125;private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; //pos 调用链中当前连接点所在的位置 //n 调用链总节点长度 // Call the next filter if there is one if (pos &lt; n) &#123; //对节点进行自增 pos++ ApplicationFilterConfig filterConfig = filters[pos++]; try &#123; //当前节点小于总长度后，从filter配置类中取出filter Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() &amp;&amp; "false".equalsIgnoreCase( filterConfig.getFilterDef().getAsyncSupported())) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res, this&#125;; SecurityUtil.doAsPrivilege ("doFilter", filter, classType, args, principal); &#125; else &#123; //真正的filter filter.doFilter(request, response, this); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.filter"), e); &#125; return; &#125; // We fell off the end of the chain -- call the servlet instance //到了调用链结尾处，就真正调用servlet实例的servlet.service(request, response); try &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // Use potentially wrapped request from this point if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res&#125;; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args, principal); &#125; else &#123; servlet.service(request, response); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString("filterChain.servlet"), e); &#125; finally &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(null); lastServicedResponse.set(null); &#125; &#125;&#125;/*** Prepare for reuse of the filters and wrapper executed by this chain.* 重复使用filter调用链，pos重设为0*/void reuse() &#123; pos = 0;&#125; 重点从ApplicationFilterChain中挑出几个重要的方法拿出来分析下Filter的调用链，其实还有几处没有具体讲到，ApplicationFilterChain是合适创建的，Filter是怎么加入到ApplicationFilterChain中的。这涉及到Tomcat是怎样加载Content的，下次分析Tomcat的时候，再来具体分析，它是如何运作的，如何加载web.xml。 参考维基的责任链模式 责任链模式|菜鸟教程 Filter、FilterConfig、FilterChain|菜鸟教程 南乡清水的实际项目运用之Responsibility-Chain模式 一起学设计模式 - 责任链模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Java设计模式之策略模式]]></title>
    <url>%2F2018%2F12%2F20%2Fdesign-pattern-strategy%2F</url>
    <content type="text"><![CDATA[策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。简单理解就是一组算法，可以互换，再简单点策略就是封装算法。 意图 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用 一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决 将这些算法封装成一个一个的类，任意地替换。 主要角色 上下文Context，拥有一个Strategy的引用 抽象策略Strategy，往往是一个接口(占大部分情况)或者抽象类，通常提供各种具体策略的接口 具体策略，这就是重点了，封装了各种具体的算法 UML 应用实例 诸葛亮的锦囊妙计，每一个锦囊就是一个策略； 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略； JAVA AWT 中的 LayoutManager； 优点 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 项目描述跳转到我的策略模式GitHub 1.操作行为simple1包，主要对操作行为包装了加减乘除方法。 1234567891011121314151617@Slf4jpublic class Application &#123; public static void main(String[] args) &#123; Context context = new Context(new AddStrategy()); log.info("10 + 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new SubstractStrategy()); log.info("10 - 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new MultiplyStrategy()); log.info("10 * 5 = &#123;&#125;", context.executeStrategy(10, 5)); context.setStrategy(new DivideStrategy()); log.info("10 / 5 = &#123;&#125;", context.executeStrategy(10, 5)); &#125;&#125; 执行结果 2.出现方式simple2包描述，主要对出行方式的包装，包装了3种出行方式， 执行类 12345678910111213public class TravelApplication &#123; public static void main(String[] args) &#123; Context context = new Context(new BusStrategy()); context.executeStrategy("老王"); context.setStrategy(new BicycleStrategy()); context.executeStrategy("老张"); context.setStrategy(new WalkStrategy()); context.executeStrategy("老李"); &#125;&#125; 执行结果 策略上下文 12345678910111213141516171819@Datapublic class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 出行 * * @return */ public void executeStrategy(String name) &#123; strategy.travel(name); &#125;&#125; 抽象策略 123456789public interface Strategy &#123; /** * 出现方法 * * @return */ void travel(String name);&#125; 参考策略模式|菜鸟教程 维基里的策略模式 南乡清水的实际项目运用之Strategy模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式汇总]]></title>
    <url>%2F2018%2F12%2F19%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[设计模式23种设计模式大纲… 软件设计模式原则 构建模式 Builder （建造者模式） Abstract Factory （抽象工厂模式） Factory Method （工厂方法） Prototype （原型模式） Singleton （单例模式） 结构模式 Adapter （适配器模式） Bridge （桥接模式） Composite （组合模式） Decorator （装饰模式） Facade （外观模式） Flyweight （享元模式） Proxy （代理模式） 行为模式 Chain of Responsibility（责任链模式） Command （命令模式） Interpreter （解释器模式） Iterator（迭代器模式） Mediator（中介者模式） Memento（备忘录模式） Observer（观察者模式） State（状态模式） Strategy (策略模式) Template Method （模板方法） Visitor（访问者模式）]]></content>
      <categories>
        <category>设计模式</category>
        <category>汇总</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试评论]]></title>
    <url>%2F2018%2F12%2F18%2Ftest%2F</url>
    <content type="text"><![CDATA[测试评论]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
